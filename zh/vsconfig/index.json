[{"content":" HOOK是什么？ Hook，中文里常常被译作“钩子”或者“挂钩”，其实是Windows操作系统里的一种中断消息机制。\n是一种可以改变程序执行流程的技术，也就是讲程序原有的执行流程拦截，更改程序流向，并可以执行自己新代码的技术。\n举个不恰当的例子：\n通俗来说，就是一条高速公路，我们去追击一个罪犯(要截获的消息或事件)，然后在他要经过的地方提前埋下埋伏，等到罪犯到来时，实现截获，并执行自己的操作。\n或者说我们就是坏蛋，在要道打劫好人，“此树是我栽，此路是我开，要想过此路，留下买路财”\nHook可以干什么？ Hook技术被广泛应用于安全的多个领域，比如杀毒软件的主动防御功能，涉及到对一些敏感API的监控，就需要对这些API进行Hook；窃取密码的木马病毒，为了接收键盘的输入，需要Hook键盘消息；甚至是Windows系统及一些应用程序，在打补丁时也需要用到Hook技术。\n全局钩子 全局钩子是指在整个系统范围内拦截某种事件，比如在所有进程中拦截键盘输入。全局钩子可以用来实现一些系统级别的功能，比如全局热键、全局窗口监视等。由于全局钩子会在系统中所有进程中拦截事件，因此需要相应的权限才能够使用，而且可能会影响系统性能。\n局部钩子 局部钩子是指只在某个进程中拦截事件，比如在某个窗口中拦截键盘输入。局部钩子可以用来实现一些进程级别的功能，比如在一个应用程序中增加特定的快捷键等。局部钩子的使用相对简单，不需要特殊权限，并且不会影响整个系统的性能。\n实现键盘钩子 ","description":"","id":2,"section":"windows","tags":["HOOK"],"title":"Windows钩子","uri":"https://ayuxy.github.io/zh/windows/2023-1227-01/"},{"content":" socket：表达的含义就是通信两端的对象必须一一对应接在一起才能够工作\nsocket：\n","description":"","id":3,"section":"c","tags":["socket"],"title":"socket编程","uri":"https://ayuxy.github.io/zh/c/2023-1226-01/"},{"content":" :: windows 常见恶意 API 一览 全局钩子注入函数 设置钩子 API（setwindowsHookEx ）\n1 2 3 4 5 6 7 HHOOK WINAPI SetWindowsHookEx( _In_ int idHook,　//设置钩子的类型.意思就是我要设置的钩子是什么钩子. 可以是监视窗口过程.可以是监视消息队列. _In_ HOOKPROC lpfn,　//根据钩子类型.设置不同的回调函数. _In_ HINSTANCE hMod,　//钩子设置的Dll实例句柄,就是DLL的句柄 _In_ DWORD dwThreadId　//设置钩子的线程ID. 如果为0 则设置为全局钩子. ); //HHOOK 返回值. 是一个钩子过程句柄. 获取句柄模块（GetModuleHandle）\n1 2 3 HMODULE WINAPI GetModuleHandle( _In_opt_ LPCTSTR lpModuleName // 获取的实例句柄的文件名.可以是Dll可以使exe 如果为NULL 这是当前dll/exe的实例句柄 ); //返回值 返回实例句柄. 取消设置钩子 API （UnhookWindowsHookEx）\n1 2 3 BOOL WINAPI UnhookWindowsHookEx( _In_ HHOOK hhk //参数一是 SetWindowHookEx的返回值.也就是钩子过程句柄. ); //返回值: 返回值是BOOL类型.表示设置是否成功或者失败. 继续调用钩子链中的钩子过程 （CallNextHookEx）\n1 2 3 4 5 6 LRESULT WINAPI CallNextHookEx( _In_opt_ HHOOK hhk,\t//保存的钩子过程,也就是SetWindowsHookEx返回值. _In_ int nCode, //根据SetWindowsHookEx设置的钩子回调而产生的不同的nCode代码. 什么意思? 意思就是如果设置的钩子类型是鼠标消息.那么那个nCode就是鼠标消息.如果是键盘这是键盘 _In_ WPARAM wParam, //同2参数一样.附加参数. 根据钩子回调类型.附加参数有不同的意义.比如如果是鼠标.那么这个有可能代表的就是鼠标的x位置.键盘就可能是键代码 _In_ LPARAM lParam //同3参数一样.附加参数. ); 钩子回调\n钩子回调根据SetWindowsHookEx参数1来设定的。比如如果我们设置 WH_CBT ，那么我们设置的回调函数就是CBT回调。具体查询MSDN\n1 2 3 4 5 LRESULT CALLBACK CBTProc( // 这个回调函数里面写我们的代码就可以了. _In_ int nCode, _In_ WPARAM wParam, _In_ LPARAM lParam ); ","description":"记录一些api函数的使用方法，持续更新","id":4,"section":"windows","tags":["windows_api"],"title":"一些API函数","uri":"https://ayuxy.github.io/zh/windows/2023-1226-01/"},{"content":" VirualAllocEx 可以在其它进程空间内申请内存，与 WriteProcessMemory 配合就可以在目的进程的地址空间中制造出任何代码跟数据来，如果要让制造出来的代码运行的话，有两种方式：\n一种是获取到线程的上下文环境，然后把 EIP 修改到指定值 另一种就是在其它的进程里面创建线程，即远程线程（CreateRemoteThread） 注入DLL思路：\n首先需要将远程执行的代码写到一个DLL中，然后在目标进程中申请一块内存，将DLL文件名写入进去，最后将目标进程地址空间中的 LoadLibrary 函数当作线程函数来执行，LoadLibrary 函数加载 DLL 文件后，系统会自动运行 DLL 文件的内容\n进程访问令牌：令牌包含了用户账户的相关特权信息，当用户登录到一个windows计算机后，登陆进程验证用户的登陆凭据，登陆成功后会返回一个对应用户的各种信息的令牌，此后，当用户执行一个进程和线程的时候，这份令牌的拷贝会跟随每个进程、线程。\n用如下代码生成 naizidll.dll 文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;Windows.h\u0026gt; BOOL APIENTRY DllMain(HMODULE hmodule, DWORD reason, void *p) { switch (reason) { case DLL_PROCESS_ATTACH:\tMessageBoxA(0, \u0026#34;注入成功\u0026#34;, \u0026#34;注入成功\u0026#34;, 0);\t//dll被注入到程序后，自动执行 break; } return TRUE; } 再用如下代码生成目标文件 bazi.exe\n1 2 3 4 5 6 7 #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; void main() { printf(\u0026#34;靶子程序已经启动了。。。。\u0026#34;); system(\u0026#34;pause\u0026#34;); } 然后如下代码即可把 naizidll.dll 注入到正在运行的 bazi.exe 中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;windows.h\u0026gt; #include \u0026lt;TlHelp32.h\u0026gt; //进行注入之前首先要进行提权 int 进程提权() { int flag = 0; HANDLE 进程访问令牌; if (OpenProcessToken(GetCurrentProcess(), TOKEN_ALL_ACCESS, \u0026amp;进程访问令牌)) { TOKEN_PRIVILEGES 令牌权限; 令牌权限.PrivilegeCount = 1; LookupPrivilegeValue(NULL, SE_DEBUG_NAME, \u0026amp;令牌权限.Privileges[0].Luid);\t//遍历权限 令牌权限.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;\t//开启特权 if (AdjustTokenPrivileges(进程访问令牌, FALSE, \u0026amp;令牌权限, sizeof(令牌权限), NULL, NULL)) { flag = 1; } } CloseHandle(进程访问令牌); return flag; } //遍历进程 int _findProcess(char* name) { HANDLE 快照 = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); PROCESSENTRY32 pe32; pe32.dwSize = sizeof(PROCESSENTRY32); Process32First(快照, \u0026amp;pe32); while (Process32Next(快照,\u0026amp;pe32)) { if (_strcmpi(pe32.szExeFile,name)==0) { return pe32.th32ProcessID; } } } //注入 void dllinject(char* exename,char* dllname) { //开始注入前，先进行提权 if (进程提权() == 1) { HANDLE 目标进程id = _findProcess(exename); if (目标进程id !=0 ) { HANDLE 目标进程句柄 = OpenProcess(PROCESS_ALL_ACCESS, TRUE, 目标进程id); if (目标进程句柄 != NULL) { //开始注入 //首先 在目标进程申请一块内存 int dllLength = strlen(dllname) + 1;\t//获取dll文件的长度，+1是尾部的/0 void* dll文件名地址 = VirtualAllocEx(目标进程句柄, NULL, dllLength, MEM_COMMIT, PAGE_READWRITE);\t//读写权限，这片内存主要用于放dll文件名，不需要执行权限 if (dll文件名地址 == NULL) { printf(\u0026#34;分配内存失败\u0026#34;); } else { //把dll名写入进去 WriteProcessMemory(目标进程句柄, dll文件名地址, dllname, dllLength, 0); //创建远程线程 HMODULE hmode = GetModuleHandleA(\u0026#34;kernel32.dll\u0026#34;);\t//目标地址空间的library存在于kernel32.dll中 LPTHREAD_START_ROUTINE 函数地址 = GetProcAddress(hmode, \u0026#34;LoadLibraryA\u0026#34;);\tHANDLE hthread = CreateRemoteThread(目标进程句柄, NULL, 0, 函数地址, dll文件名地址, 0, 0);\t//创建远程线程 if (hthread == NULL) { printf(\u0026#34;远程线程创建失败\u0026#34;); } } } else { GetLastError(); printf(\u0026#34;进程打开失败\u0026#34;); } } } else { GetLastError(); printf(\u0026#34;进程提权失败\u0026#34;); } } void main() { char* exename = \u0026#34;bazi.exe\u0026#34;; char* dllname = \u0026#34;naizidll.dll\u0026#34;; dllinject(exename, dllname); system(\u0026#34;pause\u0026#34;); } 执行结果如下：\n注意：上面的代码是注入到 32 位程序，并且对于 QQ 等存在保护的程序是无法注入的\n在注入 dll 注入到程序后，会自动执行，但是有的 dll 注入工具会让我们选择注入后加载执行的函数，如下：\n上面的功能如何实现呢 ？\n比如：我们想要加载如下 DLLproject.dll 的时候执行 MessageBoxA(0, \u0026quot;fn注入成功\u0026quot;, \u0026quot;fn注入成功\u0026quot;, 0);\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;Windows.h\u0026gt; _declspec(dllexport) void fn() { MessageBoxA(0, \u0026#34;fn注入成功\u0026#34;, \u0026#34;fn注入成功\u0026#34;, 0); } BOOL APIENTRY DllMain(HMODULE hmodule, DWORD reason, void* p) { switch (reason) { case DLL_PROCESS_ATTACH: MessageBoxA(0, \u0026#34;注入成功\u0026#34;, \u0026#34;注入成功\u0026#34;, 0);\t//dll被注入到程序后，自动执行 break; } return TRUE; } 执行如下代码，第一次弹出注入成功，第二次弹出注入成功，第三次弹出fn注入成功\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;windows.h\u0026gt; #include \u0026lt;TlHelp32.h\u0026gt; //进行注入之前首先要进行提权 int 进程提权() { int flag = 0; HANDLE 进程访问令牌; if (OpenProcessToken(GetCurrentProcess(), TOKEN_ALL_ACCESS, \u0026amp;进程访问令牌)) { TOKEN_PRIVILEGES 令牌权限; 令牌权限.PrivilegeCount = 1; LookupPrivilegeValue(NULL, SE_DEBUG_NAME, \u0026amp;令牌权限.Privileges[0].Luid);\t//遍历权限 令牌权限.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;\t//开启特权 if (AdjustTokenPrivileges(进程访问令牌, FALSE, \u0026amp;令牌权限, sizeof(令牌权限), NULL, NULL)) { flag = 1; } } CloseHandle(进程访问令牌); return flag; } //遍历进程 int _findProcess(char* name) { HANDLE 快照 = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); PROCESSENTRY32 pe32; pe32.dwSize = sizeof(PROCESSENTRY32); Process32First(快照, \u0026amp;pe32); while (Process32Next(快照,\u0026amp;pe32)) { if (_strcmpi(pe32.szExeFile,name)==0) { return pe32.th32ProcessID; } } } //注入 void dllinject(char* exename,char* dllname, char* fnnanme) { HMODULE dll模块首地址 = LoadLibraryA(dllname);\t//第一次弹出注入成功 void(*fn函数地址) = (void(*)())GetProcAddress(dll模块首地址, fnnanme);\t//获取 fnname函数地址 int 偏移量 = (char*)fn函数地址 - (char*)dll模块首地址; //开始注入前，先进行提权 if (进程提权() == 1) { HANDLE 目标进程id = _findProcess(exename); if (目标进程id !=0 ) { HANDLE 目标进程句柄 = OpenProcess(PROCESS_ALL_ACCESS, TRUE, 目标进程id); if (目标进程句柄 != NULL) { //开始注入 //首先 在目标进程申请一块内存 int dllLength = strlen(dllname) + 1;\t//获取dll文件的长度，+1是尾部的/0 void* dll文件名地址 = VirtualAllocEx(目标进程句柄, NULL, dllLength, MEM_COMMIT, PAGE_READWRITE);\t//读写权限，这片内存主要用于放dll文件名，不需要执行权限 if (dll文件名地址 == NULL) { printf(\u0026#34;分配内存失败\u0026#34;); } else { //把dll名写入进去 WriteProcessMemory(目标进程句柄, dll文件名地址, dllname, dllLength, 0); //创建远程线程 HMODULE hmode = GetModuleHandleA(\u0026#34;kernel32.dll\u0026#34;);\t//目标地址空间的library存在于kernel32.dll中 LPTHREAD_START_ROUTINE 函数地址 = GetProcAddress(hmode, \u0026#34;LoadLibraryA\u0026#34;);\t//第二次弹出注入成功， HANDLE hthread = CreateRemoteThread(目标进程句柄, NULL, 0, 函数地址, dll文件名地址, 0, 0);\t//创建远程线程 if (hthread == NULL) { GetLastError(); printf(\u0026#34;远程线程创建失败\u0026#34;); } WaitForSingleObject(hthread,INFINITE); DWORD dll模块 = 0; GetExitCodeThread(hthread, \u0026amp;dll模块); void(*fn)() = (void(*)())(dll模块 + 偏移量); hthread = CreateRemoteThread(目标进程句柄, NULL, 0, (LPTHREAD_START_ROUTINE)fn, 0, 0, 0);\t//创建远程线程\t//第三次弹出 fn注入成功 if (hthread == NULL) {\tGetLastError(); printf(\u0026#34;远程线程创建失败\u0026#34;); } WaitForSingleObject(hthread, INFINITE); } } else { GetLastError(); printf(\u0026#34;进程打开失败\u0026#34;); } CloseHandle(目标进程句柄); } } else { GetLastError(); printf(\u0026#34;进程提权失败\u0026#34;); } } void main() { char* exename = \u0026#34;bazi.exe\u0026#34;; char* dllname = \u0026#34;DLLproject.dll\u0026#34;; dllinject(exename, dllname,\u0026#34;fn\u0026#34;); system(\u0026#34;pause\u0026#34;); } 上面的 DLL 注入都存在一些弊端，我们通过火绒剑等工具完全可以看到注入到进程里面的DLL模块：\n有两种办法解决上面问题：\n以汇编的形式注入 傀儡进程 ","description":"","id":5,"section":"c","tags":["DLL注入"],"title":"32位DLL注入","uri":"https://ayuxy.github.io/zh/c/2023-1223-01/"},{"content":" 由于 vs2022 配置 win32 汇编环境始终出现问题，所有 vs2022 里面能够安装的 msvc 版本均高于 14.26.28801，所以采用 vs2019 配置相关的环境\n但是 vs2019 的代码补全好像存在一定问题，部分情况下并不会自动补全。如下是安装了 Visual Assist x 插件的情况，如果没有安装，u.Exception.后面根本不会出现相关的补全代码，这样我们写代码就非常麻烦\n在安装 VAX 插件时遇到了很多问题，大部分破解插件都无法使用，最终完全参考该文章配置成功，为了方便以后重新配置，所以重新记录下\n环境：win10 专业版、VS2019 32位社区版（官方原版）\n相关软件如下：\n其它注意事项：安装时尽量退出杀软，装完之后对 VA_X.DLL 添加信任 （这里我并没有退出杀软和添加信任，看情况操作，只要杀软没有干掉相关破解软件就无所谓）\n安装步骤：\n关闭 vs2019，双击执行 VA_X_Setup2406_0.exe 文件（如无法执行，右键—属性—兼容性—以兼容性运行这个程序(windows 7)），等待安装。此时\n用 everything 搜索 VaXSetup.vsix，在 Temp 文件夹找到该文件，然后复制到桌面\n注意：VA_X_Setup2406_0.exe 的安装最终会发生错误，提示安装失败（不要紧），VA_X_Setup2406_0.exe 安装完后，会在 C:\\Users\\用户\\AppData\\Local\\Microsoft\\VisualStudio\\16.0_46142712\\Extensions 下生成一些文件。删除这个目录下所有文件夹和文件。（并不一定是 16.0_46142712 文件夹下的 Extensions ）\n如果 VisualStudio 下有多个类似 16.0_46142712 样式的文件夹，我们直接选择今天的即可\n双击桌面上的 VaXSetup.vsix 进行重新安装，此时会安装成功。同时会在 C:\\Users\\用户\\AppData\\Local\\Microsoft\\VisualStudio\\16.0_46142712\\Extensions 目录下生成新的文件夹和文件，如下：\n（其实对于 VS2019， VAX 是安装 Extensions 目录下的，所以如果 VAX 插件出现问题，则可以多次删除，多次重装。2010 及之前版本则不同。）\n把破解的 VA_X.dll 和 PiaoYun.dll 拷贝到 Extensions/w0ufgxid.152/ 里面，用来覆盖\n然后找到 vs2019 的安装目录，如下：\ncmd 下切换到该目录，执行 devenv.exe /safemode 命令来打开 vs2019 （安全模式下运行）\n此时在 VS2019 的扩展—管理扩展—已安装下已经有 Visual Assist x 插件，但不能使用（是灰色的），关闭 VS2019\n再正常打开 vs2019，最终会看到 extension 菜单下出现 Visual Assist x\n这还没完。需要去掉插件更新和 Visual Assist x 更新勾选，如下：\n","description":"vs2019 环境下安装 Visual Assist x 插件方法","id":6,"section":"vsconfig","tags":["vs2019"],"title":"VS2019 安装 VAX 插件","uri":"https://ayuxy.github.io/zh/vsconfig/2023-1223-01/"},{"content":"\nTitle Description 小球飞鱼 我们会一起遇见鲸鱼吗？ ","description":"","id":7,"section":"","tags":null,"title":"全部友链","uri":"https://ayuxy.github.io/zh/friendslink/"},{"content":"\t友链页面 全部 开始拜访 你敲了敲： 的门，全部友链 ","description":"","id":8,"section":"","tags":null,"title":"冲浪时间","uri":"https://ayuxy.github.io/zh/friends/"},{"content":"新的工具在原工具基础上进行了简单修改，具体如下：\n支持docker 的　-it　参数，在静默模式下　-it　参数会自动修改成　-i　参数 修改并发执行的逻辑，允许某些任务可以并发执行，而并非所有任务都并发执行 添加 ctrlc 字段，按下 ctrl+c 的时候，执行 ctrlc 字段的内容 内置了 {{YamlName}} 变量，代表 -w 加载的yaml的模板名称 支持和兼容 windwos 下的运行 编写了相关的 YAML 模板，具体如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 modules: - name: 过滤域名 parallel: false cmds: - docker run --rm --network host -v \u0026#34;$(pwd)\u0026#34;:/tools/ --name morefind1 ayuxy/tools-morefind -d -f {{file}} | docker run --rm -i --network host -v \u0026#34;$(pwd)\u0026#34;:/tools/ -w /tools/ --name httpx1 ayuxy/tools-httpx -silent -o Domain.txt silent: false ctrlc: - docker kill morefind1 httpx1 \u0026gt;/dev/null 2\u0026gt;\u0026amp;1 - name: 挖掘子域名 parallel: false cmds: - docker run --rm --network host -v \u0026#34;$(pwd)\u0026#34;:/tools/ --name morefind2 ayuxy/tools-morefind -d --root -f {{file}} | docker run --rm -i --network host -v \u0026#34;$(pwd)\u0026#34;:/tools/ -w /tools/ --name subfinder1 ayuxy/tools-subfinder -silent | docker run --rm -i --network host -v \u0026#34;$(pwd)\u0026#34;:/tools/ -w /tools/ --name httpx2 ayuxy/tools-httpx -silent -o SubDomain.txt - | line_count=$(wc -l \u0026lt; \u0026#34;SubDomain.txt\u0026#34;) echo \u0026#34;子域名扫描完成,收集到存活子域名共 $line_count 条,具体信息如下:\u0026#34; | docker run --rm -i -v $(pwd):/tools --name notify1 ayuxy/tools-notify -pc {{YamlName}} -id slack -bulk -silent - docker run --rm -v $(pwd):/tools --name notify2 ayuxy/tools-notify -pc {{YamlName}} -data SubDomain.txt -id slack -bulk -silent silent: false ctrlc: - docker kill morefind2 subfinder1 httpx2 notify1 notify2 \u0026gt;/dev/null 2\u0026gt;\u0026amp;1 - name: 端口扫描 parallel: false cmds: - docker run --rm --network host -v \u0026#34;$(pwd)\u0026#34;:/tools/ --name morefind3 ayuxy/tools-morefind -d -f SubDomain.txt | docker run --rm -i --network host -v \u0026#34;$(pwd)\u0026#34;:/tools/ --name naabu1 -w /tools/ ayuxy/tools-naabu -list SubDomain.txt -top-ports 1000 -o SubDomain_Port.txt -silent - | line_count=$(wc -l \u0026lt; \u0026#34;SubDomain_Port.txt\u0026#34;) echo \u0026#34;端口扫描完成，收集到信息共 $line_count 条,具体信息如下:\u0026#34; | docker run --rm -i -v $(pwd):/tools --name notify3 ayuxy/tools-notify -pc {{YamlName}} -id slack -bulk -silent - docker run --rm -v $(pwd):/tools --name notify4 ayuxy/tools-notify -pc {{YamlName}} -data SubDomain_Port.txt -id slack -bulk -silent silent: false ctrlc: - docker kill morefind3 naabu1 notify3 notify4 \u0026gt;/dev/null 2\u0026gt;\u0026amp;1 - name: 目录扫描 parallel: false cmds: - docker run --rm -it --network host -v \u0026#34;$(pwd)\u0026#34;:/tools/ -w /tools/ --name dirsearch1 ayuxy/tools-dirsearch -l SubDomain_Port.txt --exclude-status 405,404,402,401,400,500,501,502,503,504,505 --random-agent --format=html -o Dirsearch_Report.html silent: false ctrlc: - docker kill dirsearch1 \u0026gt;/dev/null 2\u0026gt;\u0026amp;1 - name: 过滤无效URL parallel: false cmds: - docker run --rm -v \u0026#34;$(pwd)\u0026#34;:/tools/ -w /tools/ --name dirsearch_url_filter1 ayuxy/tools-dirsearch_url_filter -f Dirsearch_Report.html -o Filter_url.txt - | line_count=$(wc -l \u0026lt; \u0026#34;Filter_url.txt\u0026#34;) echo \u0026#34;目录扫描完成,过滤掉疑似无效URL后,收集到URL共 $line_count 条,具体信息如下:\u0026#34; | docker run --rm -i -v $(pwd):/tools --name notify5 ayuxy/tools-notify -pc {{YamlName}} -id slack -bulk -silent - docker run --rm -v $(pwd):/tools --name notify6 ayuxy/tools-notify -pc {{YamlName}} -data Filter_url.txt -id slack -bulk -silent silent: false ctrlc: - docker kill dirsearch_url_filter1 notify5 notify6 \u0026gt;/dev/null 2\u0026gt;\u0026amp;1 - name: 开启指纹识别消息推送 parallel: false cmds: - ( docker run -d --rm --network host -v \u0026#34;$(pwd)\u0026#34;:/tools/ -w /tools/ --name observer_ward_notify1 ayuxy/tools-observer_ward_notify -f {{YamlName}} ) \u0026gt;/dev/null 2\u0026gt;\u0026amp;1 silent: false ctrlc: - docker kill observer_ward_notify1 \u0026gt;/dev/null 2\u0026gt;\u0026amp;1 - name: 指纹识别 parallel: false cmds: - docker run --rm -i --network host -v observer_ward_data-volume:/root/ -v \u0026#34;$(pwd)\u0026#34;:/tools/ -w /tools/ --name observer_ward1 ayuxy/tools-observer_ward -f Filter_url.txt --path /plugins --nargs \u0026#34;-etags mod-proxy\u0026#34; -c Observer_ward_result.csv --webhook http://127.0.0.1:5000/slack - sleep 2 - docker kill observer_ward_notify1 \u0026gt;/dev/null 2\u0026gt;\u0026amp;1 silent: false ctrlc: - docker kill observer_ward1 \u0026gt;/dev/null 2\u0026gt;\u0026amp;1 # notify设置 slack: - id: \u0026#34;slack\u0026#34; slack_channel: \u0026#34;recon\u0026#34; slack_username: \u0026#34;test\u0026#34; slack_format: \u0026#34;{{data}}\u0026#34; slack_webhook_url: \u0026#34;https://hooks.slack.com/services/xxxxxxxxxxxxxxxxxxxxxxxxxx\u0026#34; 由于 observer_ward 进行指纹识别的时候，匹配到指纹后，会做相关的漏洞验证，所以需要去谷歌商店下载 slack，然后填写 slack_webhook_url 配置信息，用于推送漏洞信息，测试 thinkphp 如下：\n","description":"自动化扫描工具，可用于辅助渗透测试、漏洞挖掘","id":9,"section":"tools","tags":["tools"],"title":"rayder-dev","uri":"https://ayuxy.github.io/zh/tools/2023-1120-01/"},{"content":"基础知识补充：\n查看环境变量，也可以cmd下输入set来查看\n查看环境变量，也可以用win32api查看，如下\n远程下载exe，然后执行\nSW_HIDE 是隐藏窗口，而测试的时候，可以用 SH_SHOW 显示窗口，正常会报毒，加壳可以避免一定程度报毒\n除了用 WinExec 外创建进程，还可以用 CreateProcess 创建进程\n1 2 3 4 5 6 7 8 9 10 11 12 13 #define _CRT_SECURE_NO_WARNINGS #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;Windows.h\u0026gt; void main() { STARTUPINFO info; GetStartupInfo(\u0026amp;info); PROCESS_INFORMATION pinfo; CreateProcess(NULL, \u0026#34;c:/fuff.exe\u0026#34;, NULL, NULL, NULL,NULL,NULL,NULL,\u0026amp;info,\u0026amp;pinfo); } 使用 CreateProcess 时可以设置为挂起状态，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 #define _CRT_SECURE_NO_WARNINGS #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;Windows.h\u0026gt; void main() { STARTUPINFO info; GetStartupInfo(\u0026amp;info); PROCESS_INFORMATION pinfo; CreateProcess(NULL, \u0026#34;c:/fuff.exe\u0026#34;, NULL, NULL, NULL,CREATE_SUSPENDED,NULL,NULL,\u0026amp;info,\u0026amp;pinfo); ResumeThread(pinfo.hThread); } 还可以设置DEBUG_PROCESS，这样进程就可以被调试，这样设置后，当前创建进程的子进程也可以被调试，如果设置为 DEBUG_ONLY_THIS_PROCESS 则仅调试当前创建的进程，一般同时指定这两个参数就行，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 #define _CRT_SECURE_NO_WARNINGS #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;Windows.h\u0026gt; void main() { STARTUPINFO info; GetStartupInfo(\u0026amp;info); PROCESS_INFORMATION pinfo; CreateProcess(NULL, \u0026#34;c:/fuff.exe\u0026#34;, NULL, NULL, NULL, DEBUG_PROCESS | DEBUG_ONLY_THIS_PROCESS,NULL,NULL,\u0026amp;info,\u0026amp;pinfo); ResumeThread(pinfo.hThread); } 进程读写，修改游戏内存，以植物大战僵尸为案例\n由于在尝试的时候 findwindow 没有找到窗口（很奇怪），所以直接用spy查找到实际句柄\n然后ce查找内存地址\n最后可以通过 ReadProcessMemory 读取内存地址的值，可以打印出 150 个太阳\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #define _CRT_SECURE_NO_WARNINGS #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;Windows.h\u0026gt; void main() { // HANDLE 窗口句柄 = FindWindow(NULL, \u0026#34;植物大战僵尸中文版\u0026#34;); HWND 窗口句柄 = (HWND)0x002303BC; DWORD p = 0; GetWindowThreadProcessId(窗口句柄, \u0026amp;p); HANDLE hd = OpenProcess(PROCESS_ALL_ACCESS, TRUE, p); int* lp = 0x15F73908; int* num = malloc(4); ReadProcessMemory(hd,lp,num,4,NULL); printf(\u0026#34;%d\u0026#34;, *num); } 修改太阳为 10000\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #define _CRT_SECURE_NO_WARNINGS #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;Windows.h\u0026gt; void main() { // HANDLE 窗口句柄 = FindWindow(NULL, \u0026#34;植物大战僵尸中文版\u0026#34;); HWND 窗口句柄 = (HWND)0x002303BC; DWORD p = 0; GetWindowThreadProcessId(窗口句柄, \u0026amp;p); HANDLE hd = OpenProcess(PROCESS_ALL_ACCESS, TRUE, p); int* lp = 0x15F73908; int* num = malloc(4); ReadProcessMemory(hd, lp, num, 4, NULL); *num = 10000; WriteProcessMemory(hd, lp, num, 4, NULL); printf(\u0026#34;%d\u0026#34;, *num); } 利用 CreateToolhelp32Snapshot 遍历 tasklist 所有进程，CreateToolhelp32Snapshot 相当于把 tasklit 显示出的当前进程截图，然后返回，但CreateToolhelp32Snapshot 返回的进程不是实时的\nCreateToolhelp32Snapshot 可以遍历所有进程，也可以遍历一个进程里面的所有模块或者堆\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;Windows.h\u0026gt; #include \u0026lt;TlHelp32.h\u0026gt; void main() { HANDLE hd = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); PROCESSENTRY32 pe; pe.dwSize = sizeof(pe); Process32First(hd, \u0026amp;pe); while (Process32Next(hd, \u0026amp;pe)) { wprintf(L\u0026#34;%s\t%d\\n\u0026#34;, pe.szExeFile, pe.th32ProcessID); } } 关闭计算器进程\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;Windows.h\u0026gt; #include \u0026lt;TlHelp32.h\u0026gt; int main() { char* name = \u0026#34;CalculatorApp.exe\u0026#34;; HANDLE hd = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); PROCESSENTRY32 pe; pe.dwSize = sizeof(pe); Process32First(hd, \u0026amp;pe); while (Process32Next(hd, \u0026amp;pe)) { HANDLE 进程 = OpenProcess(PROCESS_ALL_ACCESS, TRUE, pe.th32ProcessID); if (进程 != NULL) { if (strcmp(name, pe.szExeFile) == 0) { if (TerminateProcess(进程, 0)) { printf(\u0026#34;Terminated process: %s\\n\u0026#34;, pe.szExeFile); } else { DWORD error = GetLastError(); printf(\u0026#34;Failed to terminate process: %lu\\n\u0026#34;, error); } } CloseHandle(进程); } else { DWORD error = GetLastError(); wprintf(L\u0026#34;Failed to open process: %lu, %s\\n\u0026#34;, error, pe.szExeFile); } } CloseHandle(hd); return 0; } 这里关闭失败了，结果如下，5 表示权限不够，可能要提权才能够关闭（不是很清楚）\n打印计算器进程的模块\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;Windows.h\u0026gt; #include \u0026lt;TlHelp32.h\u0026gt; void main() { char name[30] = \u0026#34;CalculatorApp.exe\u0026#34;; HANDLE hd = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, NULL); MODULEENTRY32 module; module.dwSize = sizeof(module); Module32First(hd, \u0026amp;module); while (Module32Next(hd, \u0026amp;module)) { wprintf(L\u0026#34;%s\\n\u0026#34;, module.szExePath); } } 编译如下汇编代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 .386 .model flat, stdcall option casemap:none include D:\\masm32\\include\\user32.inc include D:\\masm32\\include\\windows.inc include D:\\masm32\\include\\kernel32.inc .data Err db \u0026#39;乃子哥哥爱吃槟榔\u0026#39;,0 Ok db \u0026#39;乃子哥哥爱看黄色\u0026#39;,0 caption db \u0026#39;乃子哥哥yyds\u0026#39;,0 .code fn proc xor eax,eax .if eax invoke MessageBoxA, NULL, addr Ok, addr caption, MB_OK .elseif invoke MessageBoxA, NULL, addr Err, addr caption, MB_ICONSTOP .endif ret fn endp start: invoke fn invoke ExitProcess, 0 end start 然后用ollylce调试\n注意：\n多次重复用ollylce加载发现je跳转的地址始终不发现变化，pe的exe文件反汇编后开始的地址短时间内不会发生改变。\n但对于dll文件，dll在物理内存中只有一份，dll文件是通过分页机制映射到虚拟内存中的，虚拟地址空间是隔离的，但是如果虚拟内存空间被占用了，那么就需要重定位，所以dll文件反汇编的开始地址并不一定是相同的，可能发生变化，这样我们就需要遍历整个模块的空间来找到起始地址\n但是由于这里是 exe 文件，所以短时间内程序入口地址不会变化，即 0x0059206B 不会变化，所以0x00592040肯定也不会变化，那么如果我们能够读取 0x00592040的地址对应的值1574（小端存储，7415也就是1574），并且修改成 9090 （也就是nop），那么就能够模仿上面在ce 中调试修改的操作，也就相当于补丁\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #define _CRT_SECURE_NO_WARNINGS #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;Windows.h\u0026gt; #include \u0026lt;tchar.h\u0026gt; void main() { STARTUPINFO info; GetStartupInfo(\u0026amp;info); PROCESS_INFORMATION pinfo; if (CreateProcess(_T(\u0026#34;C:\\\\MASM.exe\u0026#34;), NULL, NULL, NULL, NULL, NULL, NULL, NULL, \u0026amp;info, \u0026amp;pinfo)) { printf(\u0026#34;进程创建成功\\n\u0026#34;); } else { DWORD error = GetLastError(); printf(\u0026#34;进程创建失败，错误码: %d\\n\u0026#34;, error); } void* p = 0x00592040; short oldbyte = 0x1574; short* newbyte = malloc(2); HANDLE hd = OpenProcess(PROCESS_ALL_ACCESS, TRUE, pinfo.dwProcessId); ReadProcessMemory(hd, p, newbyte, 2, NULL); if (oldbyte != *newbyte) { printf(\u0026#34;程序版本不对，无法添加补丁\u0026#34;); } else { *newbyte = 0x9090; WriteProcessMemory(hd, p, newbyte, 2, NULL); } } 执行结果如下：\n对 exe 进行upx加壳后，再用OllyICE进行F8单步调试，则发现一直在来回跳，无法继续往下执行（加壳就是防止反调试）\n以前的壳分为两种：\n一种是专门用于把代码压缩，降低可执行文件体积，比如压缩后是 123.exe，那么 123.exe 中当然还有一个解压缩代码 第二种就是对代码进行加密 现在的壳一般同时具备压缩和加密两种特性\n如何对加壳的程序进行打补丁 ？？\n把加壳后的程序拖入调试器，显示如下：\n解压缩代码的最后有一个跳转\n执行完解压缩代码后，进行跳转，再执行原本的程序\n如果直接跳过运行这段解压缩代码，直接从最后 jmp 开始执行\n最后结果如下，发现无法跳转到原来的程序中，所以解压缩代码无法跳过\n但是如果我们运行完解压缩代码后，再执行 jmp 跳转，那么就可以跳转到原来的程序中\n可以模拟上面的思路，编写代码模拟上面调试器的过程，当解压缩代码执行完，然后跳转到原来的程序中后，再进行打补丁\n具体代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 #define _CRT_SECURE_NO_WARNINGS #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;Windows.h\u0026gt; #include \u0026lt;tchar.h\u0026gt; unsigned char int3 = 0xcc; char* 要下断点的地址 = 0x009EADAA; unsigned char 原来的机器码 = 0; void* 补丁地址 = 0x009E2040; unsigned short 补丁 = 0x9090; void main(int arc,char* arv[],char* env[]) { STARTUPINFO info; GetStartupInfo(\u0026amp;info); PROCESS_INFORMATION pinfo; CreateProcess(_T(\u0026#34;C:\\\\upx_test.exe\u0026#34;), NULL, NULL, NULL, NULL, DEBUG_PROCESS | DEBUG_ONLY_THIS_PROCESS, NULL, NULL, \u0026amp;info, \u0026amp;pinfo); CONTEXT 线程的上下文; DEBUG_EVENT event; while (1) { WaitForDebugEvent(\u0026amp;event, INFINITE);\t//win32调试api if (event.dwDebugEventCode == EXIT_PROCESS_DEBUG_EVENT) {\t//判断被调试进程是否退出 break; } if (event.dwDebugEventCode == CREATE_PROCESS_DEBUG_EVENT) {\t//进程被创建 ReadProcessMemory(pinfo.hProcess, 要下断点的地址, \u0026amp;原来的机器码, 1, NULL);\t//用于保存原来的机器码 WriteProcessMemory(pinfo.hProcess, 要下断点的地址, \u0026amp;int3, 1, NULL);\t//下断点 } //EXCEPTION_DEBUG_EVENT：当被调试进程发生异常事件，被调试进程开始执行第一个条指令前本事件发生一次，之后只有在单步中断和断点中断才会发生这个事件 else if (event.dwDebugEventCode == EXCEPTION_DEBUG_EVENT) { if (event.u.Exception.ExceptionRecord.ExceptionCode == EXCEPTION_BREAKPOINT) //如果是断点中断 { 线程的上下文.ContextFlags = CONTEXT_FULL; GetThreadContext(pinfo.hThread, \u0026amp;线程的上下文); if (线程的上下文.Eip == 要下断点的地址+1) { WriteProcessMemory(pinfo.hProcess, 要下断点的地址, \u0026amp;原来的机器码, 1, NULL); 线程的上下文.Eip--; SetThreadContext(pinfo.hThread, \u0026amp;线程的上下文); WriteProcessMemory(pinfo.hProcess,补丁地址, \u0026amp;补丁, 2, NULL); } } } //当被调试的进程发生与调试事件有关时，windows 就会将目标进程的线程挂起并给调试器发送一个事件通知，调试器使用 WaitForDebugEvent 函数获取这些事件，在处理完这些事件后，要用 ContinueDebugEvent 来恢复。 ContinueDebugEvent(event.dwProcessId, event.dwThreadId, DBG_CONTINUE); } CloseHandle(pinfo.hProcess); CloseHandle(pinfo.hThread); } 上面的代码是断点中断，但是当代码进入断点中断后，还可以再进行单步调试（中断）\neflags 的 tf 位等于1的时候，CPU 处于单步执行指令的方式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 #define _CRT_SECURE_NO_WARNINGS #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;Windows.h\u0026gt; #include \u0026lt;tchar.h\u0026gt; unsigned char int3 = 0xcc; char* 要下断点的地址 = 0x009EADAA; unsigned char 原来的机器码 = 0; void* 补丁地址 = 0x009E2040; unsigned short 补丁 = 0x9090; void main(int arc,char* arv[],char* env[]) { STARTUPINFO info; GetStartupInfo(\u0026amp;info); PROCESS_INFORMATION pinfo; CreateProcess(_T(\u0026#34;C:\\\\upx_test.exe\u0026#34;), NULL, NULL, NULL, NULL, DEBUG_PROCESS, NULL, NULL, \u0026amp;info, \u0026amp;pinfo); CONTEXT 线程的上下文; DEBUG_EVENT event; while (1) { WaitForDebugEvent(\u0026amp;event, INFINITE);\t//win32调试api if (event.dwDebugEventCode == EXIT_PROCESS_DEBUG_EVENT) {\t//判断被调试进程是否退出 break; } if (event.dwDebugEventCode == CREATE_PROCESS_DEBUG_EVENT) {\t//进程被创建 ReadProcessMemory(pinfo.hProcess, 要下断点的地址, \u0026amp;原来的机器码, 1, NULL);\t//用于保存原来的机器码 WriteProcessMemory(pinfo.hProcess, 要下断点的地址, \u0026amp;int3, 1, NULL);\t//下断点 } //EXCEPTION_DEBUG_EVENT：当被调试进程发生异常事件，被调试进程开始执行第一个条指令前本事件发生一次，之后只有在单步中断和断点中断才会发生这个事件 else if (event.dwDebugEventCode == EXCEPTION_DEBUG_EVENT) { if (event.u.Exception.ExceptionRecord.ExceptionCode == EXCEPTION_BREAKPOINT) //如果是断点中断 { 线程的上下文.ContextFlags = CONTEXT_FULL; GetThreadContext(pinfo.hThread, \u0026amp;线程的上下文); if (线程的上下文.Eip == 要下断点的地址+1) { WriteProcessMemory(pinfo.hProcess, 要下断点的地址, \u0026amp;原来的机器码, 1, NULL); 线程的上下文.Eip--; 线程的上下文.EFlags |= 0x100; //设置单步调试 SetThreadContext(pinfo.hThread, \u0026amp;线程的上下文); } } else if (event.u.Exception.ExceptionRecord.ExceptionCode == EXCEPTION_SINGLE_STEP)\t//如果是单步中断 { // 如果是单步调试 线程的上下文.ContextFlags = CONTEXT_FULL; GetThreadContext(pinfo.hThread, \u0026amp;线程的上下文); char ch = 0; putchar(\u0026#39;-\u0026#39;); scanf(\u0026#34;%c\u0026#34;, \u0026amp;ch); getchar(); printf(\u0026#34;寄存器eip:%08x eflags:%08x\tesp:%08x\\n\u0026#34;,线程的上下文.Eip,线程的上下文.EFlags,线程的上下文.Esp); 线程的上下文.EFlags |= 0x100; //设置单步调试 SetThreadContext(pinfo.hThread, \u0026amp;线程的上下文); } } //当被调试的进程发生与调试事件有关时，windows 就会将目标进程的线程挂起并给调试器发送一个事件通知，调试器使用 WaitForDebugEvent 函数获取这些事件，在处理完这些事件后，要用 ContinueDebugEvent 来恢复。 ContinueDebugEvent(event.dwProcessId, event.dwThreadId, DBG_CONTINUE); } CloseHandle(pinfo.hProcess); CloseHandle(pinfo.hThread); } 上面代码执行后，输入 t 即可单步调试获取相关寄存器的值\n","description":"","id":10,"section":"c","tags":["补丁","进程遍历","win32api调试"],"title":"进程遍历 | 内存补丁 | win32 api调试","uri":"https://ayuxy.github.io/zh/c/2023-1120-01/"},{"content":"进制转换 bit（比特） = 一个bit是一个0或1，叫做一个二进制位 byte（字节）= 1byte 是 8 个比特 16进制 = 4个2进制 CPU组成 一个典型的CPU大概由运算器、控制器、寄存器构成。外部总线实现CPU和主板上其他器件的联系，内部总线实现CPU内部各个部件的链接\n8086 CPU 8086 CPU （Intel 8086 是一个由Intel于1978年所设计的16位微处理器芯片，是x86架构的鼻祖）有14个16位寄存器 AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW，其中AX，BX，CX，DX 这4个通常用来存放一般性数据，被称为通用寄存器\n注意：8086 CPU 的上一代，也就是8086 CPU 的老爸实际是8位的，当然8086是16位的兼容8位的，所以为了兼容上一代的CPU， AX 寄存器（16位）可以分为两个独立的8位寄存器 AH，AL。同理，BX可分为BH、BL。CX分为CH、CL。DX分为DH、DL。\n","description":"8086汇编基础知识","id":11,"section":"asm","tags":["8086汇编"],"title":"8086汇编","uri":"https://ayuxy.github.io/zh/asm/8086/2023-1120-01/"},{"content":" 稿定设计官网\n然后不要 关闭控制台，刷新即可\n但这样比较麻烦，可以利用插件 uBlock Origin 添加过滤规则，如下：\n这样每次打开稿定设计都是无水印，之后自行截图即可\n","description":"搞定设计网页版去水印方法","id":12,"section":"other","tags":[null],"title":"稿定设计去水印","uri":"https://ayuxy.github.io/zh/other/2023-1005-01/"},{"content":" 线程 弹窗5次，代码如下：\n1 2 3 4 5 6 7 8 #include \u0026lt;stdbool.h\u0026gt; #include \u0026lt;windows.h\u0026gt; void main() { for (size_t i = 0;i \u0026lt; 5;i++) { MessageBoxA(0, \u0026#34;窗口\u0026#34;, \u0026#34;hacker\u0026#34;, 0); } } 创建线程，再次弹窗\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;stdbool.h\u0026gt; #include \u0026lt;windows.h\u0026gt; #include \u0026lt;process.h\u0026gt; void run(void* p) { MessageBoxA(0, \u0026#34;hacker\u0026#34;, \u0026#34;弹窗\u0026#34;, 0); } void main() { for (size_t i = 0;i \u0026lt; 5;i++) { _beginthread(run, 0, NULL); } system(\u0026#34;pause\u0026#34;); } 句柄 对应的英文是handle，翻译成“把手”更恰当：你要操作某个资源，告诉操作系统这个资源的“把手”，剩余的工作交给操作系统就行了；操作系统会根据这个 “把手” 找到要操作的资源并完成操作。\n宽字符窄字符 A代表窄字符 W代表宽字符 一个项目中到底使用宽字符还是窄字符，要看其项目属性\n隐藏控制台程序黑窗口 右键项目 ——\u0026gt; 属性 ——\u0026gt; 系统，选择窗口，原来可能是控制台\n入口点填写 wmainCRTStartup 之后保存运行。如果出现错误 ，则将wmainCRTStartup 改为 mainCRTStartup\nwindows下obj、lib、dll、exe的关系 lib：静态链接库的库文件\n所谓静态就是link的时候把里面需要的东西抽取出来安排到你的exe文件中，以后运行你的exe的时候不再需要lib\ndll：动态链接库的库文件\n所谓动态就是exe运行的时候依赖于dll里面提供的功能，没有这个dll，你的exe无法运行\nlib和obj\nlib是若干obj文件的集合，本质与obj相同，没有区别，使用lib的地方都可以用obj\n从C语言编译的流程就可以看出它们的关系，如下：\n动态链接库 不仅只有DLL为后缀的是动态链接库，系统中某些exe文件、字体文件fon、系统驱动文件drv和sys、各种控件ocx，这些都可以是动态链接库，系统里面包含公用代码的模块，无论后缀名是啥，都可能是动态链接库。\n1 2 3 void dlltest() { } 对上述代码进行编译，会生成一个dll文件，如下：\n注意要想编译成功，在编译之前我们要先修改属性，如下：\n编写hacker.dll，将hacker.dll注入到计算器进程中\n1 2 3 4 #include \u0026lt;Windows.h\u0026gt; _declspec(dllexport) void hacker(){ MessageBoxA(0, \u0026#34;hacker success\u0026#34;, \u0026#34;窗口\u0026#34;, 0); } 然后修改生成的dll名称，不修改的话生成的dll为DllProject.dll，修改属性，如下：\n**\n然后利用 DllInject.exe 工具将 hacker.dll 注入到notepad++进程中\n用火绒剑发现我们已经注入成功了\n静态链接库 首先修改属性，如下：\n然后在头文件添加新建项\n然后在hacker.h中定义一个加法函数，如下：\n然后在源码中添加一个hacker.c文件\n然后在hacker.c中定义add函数的具体实现，如下：\n然后生成lib文件\n然后使用LibProject.lib库文件\n首先再添加一个LibTest的空项目\n生成后如下：\n然后将原来生成的 LibProject.lib 库文件和hacker.h头文件放到LibTest文件夹下\n然后将LibTest下的hacker.h添加到LibTest的头文件中\n同时在源文件添加空项目test.c，如下：\n然后在LibTest的属性中添加LibProject.lib，如下：\n然后在test.c文件中调用静态链接库，实现add函数\n预编译语法 预编译是C和C++通用的，C++很多的猥琐语法奇葩功能都是通过预编译实现的\n1 2 3 4 5 6 #include \u0026lt;stdio.h\u0026gt; #define go(n) printf(\u0026#34;%d\u0026#34;,n);\t//内联函数，可以提高代码运行速度 void main() { go(10) } ","description":"","id":13,"section":"c","tags":["C"],"title":"C语言基础","uri":"https://ayuxy.github.io/zh/c/2023-0126-01/"},{"content":" bibi哔哔\n2023-12-15 图片测试：\n2023-12-15 ","description":"","id":15,"section":"bibi","tags":null,"title":"哔哔","uri":"https://ayuxy.github.io/zh/bibi/bibi_page/"}]