[{"content":"\t友链页面 全部 开始拜访 你敲了敲： 的门，全部友链 ","description":"","id":2,"section":"","tags":null,"title":"冲浪时间","uri":"https://ayuxy.github.io/zh/friends/"},{"content":"基础知识补充：\n查看环境变量，也可以cmd下输入set来查看\n查看环境变量，也可以用win32api查看，如下\n远程下载exe，然后执行\nSW_HIDE 是隐藏窗口，而测试的时候，可以用 SH_SHOW 显示窗口，正常会报毒，加壳可以避免一定程度报毒\n除了用 WinExec 外创建进程，还可以用 CreateProcess 创建进程\n1 2 3 4 5 6 7 8 9 10 11 12 13 #define _CRT_SECURE_NO_WARNINGS #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;Windows.h\u0026gt; void main() { STARTUPINFO info; GetStartupInfo(\u0026amp;info); PROCESS_INFORMATION pinfo; CreateProcess(NULL, \u0026#34;c:/fuff.exe\u0026#34;, NULL, NULL, NULL,NULL,NULL,NULL,\u0026amp;info,\u0026amp;pinfo); } 使用 CreateProcess 时可以设置为挂起状态，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 #define _CRT_SECURE_NO_WARNINGS #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;Windows.h\u0026gt; void main() { STARTUPINFO info; GetStartupInfo(\u0026amp;info); PROCESS_INFORMATION pinfo; CreateProcess(NULL, \u0026#34;c:/fuff.exe\u0026#34;, NULL, NULL, NULL,CREATE_SUSPENDED,NULL,NULL,\u0026amp;info,\u0026amp;pinfo); ResumeThread(pinfo.hThread); } 还可以设置DEBUG_PROCESS，这样进程就可以被调试，这样设置后，当前创建进程的子进程也可以被调试，如果设置为 DEBUG_ONLY_THIS_PROCESS 则仅调试当前创建的进程，一般同时指定这两个参数就行，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 #define _CRT_SECURE_NO_WARNINGS #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;Windows.h\u0026gt; void main() { STARTUPINFO info; GetStartupInfo(\u0026amp;info); PROCESS_INFORMATION pinfo; CreateProcess(NULL, \u0026#34;c:/fuff.exe\u0026#34;, NULL, NULL, NULL, DEBUG_PROCESS | DEBUG_ONLY_THIS_PROCESS,NULL,NULL,\u0026amp;info,\u0026amp;pinfo); ResumeThread(pinfo.hThread); } 进程读写，修改游戏内存，以植物大战僵尸为案例\n由于在尝试的时候 findwindow 没有找到窗口（很奇怪），所以直接用spy查找到实际句柄\n然后ce查找内存地址\n最后可以通过 ReadProcessMemory 读取内存地址的值，可以打印出 150 个太阳\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #define _CRT_SECURE_NO_WARNINGS #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;Windows.h\u0026gt; void main() { // HANDLE 窗口句柄 = FindWindow(NULL, \u0026#34;植物大战僵尸中文版\u0026#34;); HWND 窗口句柄 = (HWND)0x002303BC; DWORD p = 0; GetWindowThreadProcessId(窗口句柄, \u0026amp;p); HANDLE hd = OpenProcess(PROCESS_ALL_ACCESS, TRUE, p); int* lp = 0x15F73908; int* num = malloc(4); ReadProcessMemory(hd,lp,num,4,NULL); printf(\u0026#34;%d\u0026#34;, *num); } 修改太阳为 10000\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #define _CRT_SECURE_NO_WARNINGS #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;Windows.h\u0026gt; void main() { // HANDLE 窗口句柄 = FindWindow(NULL, \u0026#34;植物大战僵尸中文版\u0026#34;); HWND 窗口句柄 = (HWND)0x002303BC; DWORD p = 0; GetWindowThreadProcessId(窗口句柄, \u0026amp;p); HANDLE hd = OpenProcess(PROCESS_ALL_ACCESS, TRUE, p); int* lp = 0x15F73908; int* num = malloc(4); ReadProcessMemory(hd, lp, num, 4, NULL); *num = 10000; WriteProcessMemory(hd, lp, num, 4, NULL); printf(\u0026#34;%d\u0026#34;, *num); } 利用 CreateToolhelp32Snapshot 遍历 tasklist 所有进程，CreateToolhelp32Snapshot 相当于把 tasklit 显示出的当前进程截图，然后返回，但CreateToolhelp32Snapshot 返回的进程不是实时的\nCreateToolhelp32Snapshot 可以遍历所有进程，也可以遍历一个进程里面的所有模块或者堆\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;Windows.h\u0026gt; #include \u0026lt;TlHelp32.h\u0026gt; void main() { HANDLE hd = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); PROCESSENTRY32 pe; pe.dwSize = sizeof(pe); Process32First(hd, \u0026amp;pe); while (Process32Next(hd, \u0026amp;pe)) { wprintf(L\u0026#34;%s\t%d\\n\u0026#34;, pe.szExeFile, pe.th32ProcessID); } } 关闭计算器进程\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;Windows.h\u0026gt; #include \u0026lt;TlHelp32.h\u0026gt; int main() { char* name = \u0026#34;CalculatorApp.exe\u0026#34;; HANDLE hd = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); PROCESSENTRY32 pe; pe.dwSize = sizeof(pe); Process32First(hd, \u0026amp;pe); while (Process32Next(hd, \u0026amp;pe)) { HANDLE 进程 = OpenProcess(PROCESS_ALL_ACCESS, TRUE, pe.th32ProcessID); if (进程 != NULL) { if (strcmp(name, pe.szExeFile) == 0) { if (TerminateProcess(进程, 0)) { printf(\u0026#34;Terminated process: %s\\n\u0026#34;, pe.szExeFile); } else { DWORD error = GetLastError(); printf(\u0026#34;Failed to terminate process: %lu\\n\u0026#34;, error); } } CloseHandle(进程); } else { DWORD error = GetLastError(); wprintf(L\u0026#34;Failed to open process: %lu, %s\\n\u0026#34;, error, pe.szExeFile); } } CloseHandle(hd); return 0; } 这里关闭失败了，结果如下，5 表示权限不够，可能要提权才能够关闭（不是很清楚）\n打印计算器进程的模块\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;Windows.h\u0026gt; #include \u0026lt;TlHelp32.h\u0026gt; void main() { char name[30] = \u0026#34;CalculatorApp.exe\u0026#34;; HANDLE hd = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, NULL); MODULEENTRY32 module; module.dwSize = sizeof(module); Module32First(hd, \u0026amp;module); while (Module32Next(hd, \u0026amp;module)) { wprintf(L\u0026#34;%s\\n\u0026#34;, module.szExePath); } } 编译如下汇编代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 .386 .model flat, stdcall option casemap:none include D:\\masm32\\include\\user32.inc include D:\\masm32\\include\\windows.inc include D:\\masm32\\include\\kernel32.inc .data Err db \u0026#39;乃子哥哥爱吃槟榔\u0026#39;,0 Ok db \u0026#39;乃子哥哥爱看黄色\u0026#39;,0 caption db \u0026#39;乃子哥哥yyds\u0026#39;,0 .code fn proc xor eax,eax .if eax invoke MessageBoxA, NULL, addr Ok, addr caption, MB_OK .elseif invoke MessageBoxA, NULL, addr Err, addr caption, MB_ICONSTOP .endif ret fn endp start: invoke fn invoke ExitProcess, 0 end start 然后用ollylce调试\n注意：\n多次重复用ollylce加载发现je跳转的地址始终不发现变化，pe的exe文件反汇编后开始的地址短时间内不会发生改变。\n但对于dll文件，dll在物理内存中只有一份，dll文件是通过分页机制映射到虚拟内存中的，虚拟地址空间是隔离的，但是如果虚拟内存空间被占用了，那么就需要重定位，所以dll文件反汇编的开始地址并不一定是相同的，可能发生变化，这样我们就需要遍历整个模块的空间来找到起始地址\n但是由于这里是 exe 文件，所以短时间内程序入口地址不会变化，即 0x0059206B 不会变化，所以0x00592040肯定也不会变化，那么如果我们能够读取 0x00592040的地址对应的值1574（小端存储，7415也就是1574），并且修改成 9090 （也就是nop），那么就能够模仿上面在ce 中调试修改的操作，也就相当于补丁\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #define _CRT_SECURE_NO_WARNINGS #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;Windows.h\u0026gt; #include \u0026lt;tchar.h\u0026gt; void main() { STARTUPINFO info; GetStartupInfo(\u0026amp;info); PROCESS_INFORMATION pinfo; if (CreateProcess(_T(\u0026#34;C:\\\\MASM.exe\u0026#34;), NULL, NULL, NULL, NULL, NULL, NULL, NULL, \u0026amp;info, \u0026amp;pinfo)) { printf(\u0026#34;进程创建成功\\n\u0026#34;); } else { DWORD error = GetLastError(); printf(\u0026#34;进程创建失败，错误码: %d\\n\u0026#34;, error); } void* p = 0x00592040; short oldbyte = 0x1574; short* newbyte = malloc(2); HANDLE hd = OpenProcess(PROCESS_ALL_ACCESS, TRUE, pinfo.dwProcessId); ReadProcessMemory(hd, p, newbyte, 2, NULL); if (oldbyte != *newbyte) { printf(\u0026#34;程序版本不对，无法添加补丁\u0026#34;); } else { *newbyte = 0x9090; WriteProcessMemory(hd, p, newbyte, 2, NULL); } } 执行结果如下：\n对 exe 进行upx加壳后，再用OllyICE进行F8单步调试，则发现一直在来回跳，无法继续往下执行（加壳就是防止反调试）\n以前的壳分为两种：\n一种是专门用于把代码压缩，降低可执行文件体积，比如压缩后是 123.exe，那么 123.exe 中当然还有一个解压缩代码 第二种就是对代码进行加密 现在的壳一般同时具备压缩和加密两种特性\n如何对加壳的程序进行打补丁 ？？\n把加壳后的程序拖入调试器，显示如下：\n解压缩代码的最后有一个跳转\n执行完解压缩代码后，进行跳转，再执行原本的程序\n如果直接跳过运行这段解压缩代码，直接从最后 jmp 开始执行\n最后结果如下，发现无法跳转到原来的程序中，所以解压缩代码无法跳过\n但是如果我们运行完解压缩代码后，再执行 jmp 跳转，那么就可以跳转到原来的程序中\n可以利用上面的思路，编写代码模拟上面调试器的过程，当解压缩代码执行完，然后跳转到原来的程序中后，再进行打补丁\n具体代码如下：\n1 da 当被调试的进程发生与调试事件有关时，windows 就会\n","description":"","id":4,"section":"c","tags":["C"],"title":"进程遍历 | 内存补丁 | win32 api调试","uri":"https://ayuxy.github.io/zh/c/2023-1128-01/"},{"content":"汇编语言是直接工作在硬件之上的语言，首先要了解硬件系统的结构，才能有效应用汇编语言对其编程\n机器语言 ","description":"汇编语言是直接工作在硬件之上的语言，首先要了解硬件系统的结构，才能有效应用汇编语言对其编程","id":5,"section":"asm","tags":["8086汇编"],"title":"8086汇编基础","uri":"https://ayuxy.github.io/zh/asm/8086/2023-1121-05/"},{"content":" 测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试\n2023-12-16 2023-12-15 ","description":"","id":7,"section":"bibi","tags":null,"title":"哔哔","uri":"https://ayuxy.github.io/zh/bibi/bibi_page/"}]